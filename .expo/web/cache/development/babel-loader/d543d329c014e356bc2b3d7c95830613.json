{
  "ast": null,
  "code": "var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useRadio = useRadio;\nexports.useRadioGroup = useRadioGroup;\n\nvar _i18n = require(\"@react-aria/i18n\");\n\nvar _label = require(\"@react-aria/label\");\n\nvar _interactions = require(\"@react-aria/interactions\");\n\nvar _focus = require(\"@react-aria/focus\");\n\nvar _utils = require(\"@react-aria/utils\");\n\nvar _extends = _interopRequireDefault(require(\"@babel/runtime/helpers/esm/extends\"));\n\nvar $a7d0e5df3871fb1bfdb437cffdabab2a$export$radioGroupNames = new WeakMap();\n\nfunction useRadio(props, state, ref) {\n  var value = props.value,\n      children = props.children,\n      ariaLabel = props['aria-label'],\n      ariaLabelledby = props['aria-labelledby'];\n  var isDisabled = props.isDisabled || state.isDisabled;\n  var hasChildren = children != null;\n  var hasAriaLabel = ariaLabel != null || ariaLabelledby != null;\n\n  if (!hasChildren && !hasAriaLabel) {\n    console.warn('If you do not provide children, you must specify an aria-label for accessibility');\n  }\n\n  var checked = state.selectedValue === value;\n\n  var onChange = function onChange(e) {\n    e.stopPropagation();\n    state.setSelectedValue(value);\n  };\n\n  var _usePress = (0, _interactions.usePress)({\n    isDisabled: isDisabled\n  }),\n      pressProps = _usePress.pressProps;\n\n  var _useFocusable = (0, _focus.useFocusable)((0, _utils.mergeProps)(props, {\n    onFocus: function onFocus() {\n      return state.setLastFocusedValue(value);\n    }\n  }), ref),\n      focusableProps = _useFocusable.focusableProps;\n\n  var interactions = (0, _utils.mergeProps)(pressProps, focusableProps);\n  var domProps = (0, _utils.filterDOMProps)(props, {\n    labelable: true\n  });\n  var tabIndex = state.lastFocusedValue === value || state.lastFocusedValue == null ? 0 : -1;\n\n  if (isDisabled) {\n    tabIndex = undefined;\n  }\n\n  return {\n    inputProps: (0, _utils.mergeProps)(domProps, (0, _extends.default)({}, interactions, {\n      type: 'radio',\n      name: $a7d0e5df3871fb1bfdb437cffdabab2a$export$radioGroupNames.get(state),\n      tabIndex: tabIndex,\n      disabled: isDisabled,\n      checked: checked,\n      value: value,\n      onChange: onChange\n    }))\n  };\n}\n\nfunction useRadioGroup(props, state) {\n  var name = props.name,\n      validationState = props.validationState,\n      isReadOnly = props.isReadOnly,\n      isRequired = props.isRequired,\n      isDisabled = props.isDisabled,\n      _props$orientation = props.orientation,\n      orientation = _props$orientation === void 0 ? 'vertical' : _props$orientation;\n\n  var _useLocale = (0, _i18n.useLocale)(),\n      direction = _useLocale.direction;\n\n  var _useLabel = (0, _label.useLabel)((0, _extends.default)({}, props, {\n    labelElementType: 'span'\n  })),\n      labelProps = _useLabel.labelProps,\n      fieldProps = _useLabel.fieldProps;\n\n  var domProps = (0, _utils.filterDOMProps)(props, {\n    labelable: true\n  });\n\n  var _useFocusWithin = (0, _interactions.useFocusWithin)({\n    onBlurWithin: function onBlurWithin() {\n      if (!state.selectedValue) {\n        state.setLastFocusedValue(null);\n      }\n    }\n  }),\n      focusWithinProps = _useFocusWithin.focusWithinProps;\n\n  var onKeyDown = function onKeyDown(e) {\n    var nextDir;\n\n    switch (e.key) {\n      case 'ArrowRight':\n        if (direction === 'rtl' && orientation !== 'vertical') {\n          nextDir = 'prev';\n        } else {\n          nextDir = 'next';\n        }\n\n        break;\n\n      case 'ArrowLeft':\n        if (direction === 'rtl' && orientation !== 'vertical') {\n          nextDir = 'next';\n        } else {\n          nextDir = 'prev';\n        }\n\n        break;\n\n      case 'ArrowDown':\n        nextDir = 'next';\n        break;\n\n      case 'ArrowUp':\n        nextDir = 'prev';\n        break;\n\n      default:\n        return;\n    }\n\n    e.preventDefault();\n    var walker = (0, _focus.getFocusableTreeWalker)(e.currentTarget, {\n      from: e.target\n    });\n    var nextElem;\n\n    if (nextDir === 'next') {\n      nextElem = walker.nextNode();\n\n      if (!nextElem) {\n        walker.currentNode = e.currentTarget;\n        nextElem = walker.firstChild();\n      }\n    } else {\n      nextElem = walker.previousNode();\n\n      if (!nextElem) {\n        walker.currentNode = e.currentTarget;\n        nextElem = walker.lastChild();\n      }\n    }\n\n    if (nextElem) {\n      nextElem.focus();\n      state.setSelectedValue(nextElem.value);\n    }\n  };\n\n  var groupName = (0, _utils.useId)(name);\n  $a7d0e5df3871fb1bfdb437cffdabab2a$export$radioGroupNames.set(state, groupName);\n  return {\n    radioGroupProps: (0, _utils.mergeProps)(domProps, (0, _extends.default)({\n      role: 'radiogroup',\n      onKeyDown: onKeyDown,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': props['aria-errormessage'],\n      'aria-readonly': isReadOnly || undefined,\n      'aria-required': isRequired || undefined,\n      'aria-disabled': isDisabled || undefined,\n      'aria-orientation': orientation\n    }, fieldProps, focusWithinProps)),\n    labelProps: labelProps\n  };\n}",
  "map": {
    "version": 3,
    "sources": [
      "packages/@react-aria/radio/src/utils.ts",
      "packages/@react-aria/radio/src/useRadio.ts",
      "packages/@react-aria/radio/src/useRadioGroup.ts"
    ],
    "names": [
      "radioGroupNames",
      "ariaLabelledby",
      "isDisabled",
      "props",
      "state",
      "hasChildren",
      "children",
      "hasAriaLabel",
      "ariaLabel",
      "console",
      "checked",
      "onChange",
      "e",
      "pressProps",
      "usePress",
      "focusableProps",
      "useFocusable",
      "mergeProps",
      "onFocus",
      "interactions",
      "domProps",
      "filterDOMProps",
      "labelable",
      "tabIndex",
      "inputProps",
      "type",
      "name",
      "disabled",
      "value",
      "orientation",
      "direction",
      "fieldProps",
      "useLabel",
      "labelElementType",
      "focusWithinProps",
      "useFocusWithin",
      "onBlurWithin",
      "onKeyDown",
      "nextDir",
      "walker",
      "getFocusableTreeWalker",
      "from",
      "target",
      "nextElem",
      "groupName",
      "useId",
      "radioGroupProps",
      "role",
      "validationState",
      "isReadOnly",
      "isRequired",
      "labelProps"
    ],
    "mappings": "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",
    "sourcesContent": [
      "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {RadioGroupState} from '@react-stately/radio';\n\nexport const radioGroupNames = new WeakMap<RadioGroupState, string>();\n",
      "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaRadioProps} from '@react-types/radio';\nimport {filterDOMProps, mergeProps} from '@react-aria/utils';\nimport {InputHTMLAttributes, RefObject} from 'react';\nimport {radioGroupNames} from './utils';\nimport {RadioGroupState} from '@react-stately/radio';\nimport {useFocusable} from '@react-aria/focus';\nimport {usePress} from '@react-aria/interactions';\n\ninterface RadioAria {\n  /** Props for the input element. */\n  inputProps: InputHTMLAttributes<HTMLElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for an individual\n * radio button in a radio group.\n * @param props - Props for the radio.\n * @param state - State for the radio group, as returned by `useRadioGroupState`.\n * @param ref - Ref to the HTML input element.\n */\nexport function useRadio(props: AriaRadioProps, state: RadioGroupState, ref: RefObject<HTMLElement>): RadioAria {\n  let {\n    value,\n    children,\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledby\n  } = props;\n\n  const isDisabled = props.isDisabled || state.isDisabled;\n\n  let hasChildren = children != null;\n  let hasAriaLabel = ariaLabel != null || ariaLabelledby != null;\n  if (!hasChildren && !hasAriaLabel) {\n    console.warn('If you do not provide children, you must specify an aria-label for accessibility');\n  }\n\n  let checked = state.selectedValue === value;\n\n  let onChange = (e) => {\n    e.stopPropagation();\n    state.setSelectedValue(value);\n  };\n\n  let {pressProps} = usePress({\n    isDisabled\n  });\n\n  let {focusableProps} = useFocusable(mergeProps(props, {\n    onFocus: () => state.setLastFocusedValue(value)\n  }), ref);\n  let interactions = mergeProps(pressProps, focusableProps);\n  let domProps = filterDOMProps(props, {labelable: true});\n  let tabIndex = state.lastFocusedValue === value || state.lastFocusedValue == null ? 0 : -1;\n  if (isDisabled) {\n    tabIndex = undefined;\n  }\n\n  return {\n    inputProps: mergeProps(domProps, {\n      ...interactions,\n      type: 'radio',\n      name: radioGroupNames.get(state),\n      tabIndex,\n      disabled: isDisabled,\n      checked,\n      value,\n      onChange\n    })\n  };\n}\n",
      "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaRadioGroupProps} from '@react-types/radio';\nimport {filterDOMProps, mergeProps, useId} from '@react-aria/utils';\nimport {getFocusableTreeWalker} from '@react-aria/focus';\nimport {HTMLAttributes} from 'react';\nimport {radioGroupNames} from './utils';\nimport {RadioGroupState} from '@react-stately/radio';\nimport {useFocusWithin} from '@react-aria/interactions';\nimport {useLabel} from '@react-aria/label';\nimport {useLocale} from '@react-aria/i18n';\n\ninterface RadioGroupAria {\n  /** Props for the radio group wrapper element. */\n  radioGroupProps: HTMLAttributes<HTMLElement>,\n  /** Props for the radio group's visible label (if any). */\n  labelProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a radio group component.\n * Radio groups allow users to select a single item from a list of mutually exclusive options.\n * @param props - Props for the radio group.\n * @param state - State for the radio group, as returned by `useRadioGroupState`.\n */\nexport function useRadioGroup(props: AriaRadioGroupProps, state: RadioGroupState): RadioGroupAria {\n  let {\n    name,\n    validationState,\n    isReadOnly,\n    isRequired,\n    isDisabled,\n    orientation = 'vertical'\n  } = props;\n  let {direction} = useLocale();\n\n  let {labelProps, fieldProps} = useLabel({\n    ...props,\n    // Radio group is not an HTML input element so it\n    // shouldn't be labeled by a <label> element.\n    labelElementType: 'span'\n  });\n\n  let domProps = filterDOMProps(props, {labelable: true});\n\n  // When the radio group loses focus, reset the focusable radio to null if\n  // there is no selection. This allows tabbing into the group from either\n  // direction to go to the first or last radio.\n  let {focusWithinProps} = useFocusWithin({\n    onBlurWithin() {\n      if (!state.selectedValue) {\n        state.setLastFocusedValue(null);\n      }\n    }\n  });\n\n  let onKeyDown = (e) => {\n    let nextDir;\n    switch (e.key) {\n      case 'ArrowRight':\n        if (direction === 'rtl' && orientation !== 'vertical') {\n          nextDir = 'prev';\n        } else {\n          nextDir = 'next';\n        }\n        break;\n      case 'ArrowLeft':\n        if (direction === 'rtl' && orientation !== 'vertical') {\n          nextDir = 'next';\n        } else {\n          nextDir = 'prev';\n        }\n        break;\n      case 'ArrowDown':\n        nextDir = 'next';\n        break;\n      case 'ArrowUp':\n        nextDir = 'prev';\n        break;\n      default:\n        return;\n    }\n    e.preventDefault();\n    let walker = getFocusableTreeWalker(e.currentTarget, {from: e.target});\n    let nextElem;\n    if (nextDir === 'next') {\n      nextElem = walker.nextNode();\n      if (!nextElem) {\n        walker.currentNode = e.currentTarget;\n        nextElem = walker.firstChild();\n      }\n    } else {\n      nextElem = walker.previousNode();\n      if (!nextElem) {\n        walker.currentNode = e.currentTarget;\n        nextElem = walker.lastChild();\n      }\n    }\n    if (nextElem) {\n      // Call focus on nextElem so that keyboard navigation scrolls the radio into view\n      nextElem.focus();\n      state.setSelectedValue(nextElem.value);\n    }\n  };\n\n  let groupName = useId(name);\n  radioGroupNames.set(state, groupName);\n\n  return {\n    radioGroupProps: mergeProps(domProps, {\n      // https://www.w3.org/TR/wai-aria-1.2/#radiogroup\n      role: 'radiogroup',\n      onKeyDown,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': props['aria-errormessage'],\n      'aria-readonly': isReadOnly || undefined,\n      'aria-required': isRequired || undefined,\n      'aria-disabled': isDisabled || undefined,\n      'aria-orientation': orientation,\n      ...fieldProps,\n      ...focusWithinProps\n    }),\n    labelProps\n  };\n}\n"
    ]
  },
  "metadata": {},
  "sourceType": "script"
}
