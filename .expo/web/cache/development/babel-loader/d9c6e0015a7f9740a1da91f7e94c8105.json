{
  "ast": null,
  "code": "var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createWorklet = createWorklet;\nexports.useAnimatedGestureHandler = useAnimatedGestureHandler;\nexports.useAnimatedProps = void 0;\nexports.useAnimatedReaction = useAnimatedReaction;\nexports.useAnimatedRef = useAnimatedRef;\nexports.useAnimatedScrollHandler = useAnimatedScrollHandler;\nexports.useAnimatedStyle = useAnimatedStyle;\nexports.useDerivedValue = useDerivedValue;\nexports.useEvent = useEvent;\nexports.useSharedValue = useSharedValue;\nexports.useWorkletCallback = useWorkletCallback;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _react = require(\"react\");\n\nvar _WorkletEventHandler = _interopRequireDefault(require(\"./WorkletEventHandler\"));\n\nvar _core = require(\"./core\");\n\nvar _UpdateProps = _interopRequireWildcard(require(\"./UpdateProps\"));\n\nvar _animations = require(\"./animations\");\n\nvar _NativeMethods = require(\"./NativeMethods\");\n\nvar _NativeReanimated = _interopRequireDefault(require(\"./NativeReanimated\"));\n\nvar _reactNative = require(\"react-native\");\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction useSharedValue(init) {\n  var ref = (0, _react.useRef)(null);\n\n  if (ref.current === null) {\n    ref.current = (0, _core.makeMutable)(init);\n  }\n\n  (0, _react.useEffect)(function () {\n    return function () {\n      (0, _animations.cancelAnimation)(ref.current);\n    };\n  }, []);\n  return ref.current;\n}\n\nfunction useEvent(handler) {\n  var eventNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var rebuild = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var initRef = (0, _react.useRef)(null);\n\n  if (initRef.current === null) {\n    initRef.current = new _WorkletEventHandler.default(handler, eventNames);\n  } else if (rebuild) {\n    initRef.current.updateWorklet(handler);\n  }\n\n  (0, _react.useEffect)(function () {\n    return function () {\n      initRef.current = null;\n    };\n  }, []);\n  return initRef;\n}\n\nvar prepareAnimation = function () {\n  var _f = function _f(animatedProp, lastAnimation, lastValue) {\n    function prepareAnimation(animatedProp, lastAnimation, lastValue) {\n      if (Array.isArray(animatedProp)) {\n        animatedProp.forEach(function (prop, index) {\n          return prepareAnimation(prop, lastAnimation && lastAnimation[index], lastValue && lastValue[index]);\n        });\n        return animatedProp;\n      }\n\n      if (typeof animatedProp === 'object' && animatedProp.onFrame) {\n        var animation = animatedProp;\n        var value = animation.current;\n\n        if (lastValue !== undefined) {\n          if (typeof lastValue === 'object') {\n            if (lastValue.value !== undefined) {\n              value = lastValue.value;\n            } else if (lastValue.onFrame !== undefined) {\n              if ((lastAnimation === null || lastAnimation === void 0 ? void 0 : lastAnimation.current) !== undefined) {\n                value = lastAnimation.current;\n              } else if ((lastValue === null || lastValue === void 0 ? void 0 : lastValue.current) !== undefined) {\n                value = lastValue.current;\n              }\n            }\n          } else {\n            value = lastValue;\n          }\n        }\n\n        animation.callStart = function (timestamp) {\n          animation.onStart(animation, value, timestamp, lastAnimation);\n        };\n\n        animation.callStart((0, _core.getTimestamp)());\n        animation.callStart = null;\n      } else if (typeof animatedProp === 'object') {\n        Object.keys(animatedProp).forEach(function (key) {\n          return prepareAnimation(animatedProp[key], lastAnimation && lastAnimation[key], lastValue && lastValue[key]);\n        });\n      }\n    }\n\n    return prepareAnimation(animatedProp, lastAnimation, lastValue);\n  };\n\n  _f._closure = {\n    getTimestamp: _core.getTimestamp\n  };\n  _f.asString = \"function prepareAnimation(animatedProp,lastAnimation,lastValue){const{getTimestamp}=jsThis._closure;{function prepareAnimation(animatedProp,lastAnimation,lastValue){if(Array.isArray(animatedProp)){animatedProp.forEach(function(prop,index){return prepareAnimation(prop,lastAnimation&&lastAnimation[index],lastValue&&lastValue[index]);});return animatedProp;}if(typeof animatedProp==='object'&&animatedProp.onFrame){var animation=animatedProp;var value=animation.current;if(lastValue!==undefined){if(typeof lastValue==='object'){if(lastValue.value!==undefined){value=lastValue.value;}else if(lastValue.onFrame!==undefined){if((lastAnimation===null||lastAnimation===void 0?void 0:lastAnimation.current)!==undefined){value=lastAnimation.current;}else if((lastValue===null||lastValue===void 0?void 0:lastValue.current)!==undefined){value=lastValue.current;}}}else{value=lastValue;}}animation.callStart=function(timestamp){animation.onStart(animation,value,timestamp,lastAnimation);};animation.callStart(getTimestamp());animation.callStart=null;}else if(typeof animatedProp==='object'){Object.keys(animatedProp).forEach(function(key){return prepareAnimation(animatedProp[key],lastAnimation&&lastAnimation[key],lastValue&&lastValue[key]);});}}return prepareAnimation(animatedProp,lastAnimation,lastValue);}}\";\n  _f.__workletHash = 194677483998;\n  _f.__location = \"C:\\\\Users\\\\a\\\\projects\\\\riders-app\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\Hooks.js (39:0)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nvar runAnimations = function () {\n  var _f = function _f(animation, timestamp, key, result, animationsActive) {\n    function runAnimations(animation, timestamp, key, result, animationsActive) {\n      if (!animationsActive.value) {\n        return true;\n      }\n\n      if (Array.isArray(animation)) {\n        result[key] = [];\n        var allFinished = true;\n        animation.forEach(function (entry, index) {\n          if (!runAnimations(entry, timestamp, index, result[key], animationsActive)) {\n            allFinished = false;\n          }\n        });\n        return allFinished;\n      } else if (typeof animation === 'object' && animation.onFrame) {\n        var finished = true;\n\n        if (!animation.finished) {\n          if (animation.callStart) {\n            animation.callStart(timestamp);\n            animation.callStart = null;\n          }\n\n          finished = animation.onFrame(animation, timestamp);\n          animation.timestamp = timestamp;\n\n          if (finished) {\n            animation.finished = true;\n            animation.callback && animation.callback(true);\n          }\n        }\n\n        result[key] = animation.current;\n        return finished;\n      } else if (typeof animation === 'object') {\n        result[key] = {};\n        var _allFinished = true;\n        Object.keys(animation).forEach(function (k) {\n          if (!runAnimations(animation[k], timestamp, k, result[key], animationsActive)) {\n            _allFinished = false;\n          }\n        });\n        return _allFinished;\n      } else {\n        result[key] = animation;\n        return true;\n      }\n    }\n\n    return runAnimations(animation, timestamp, key, result, animationsActive);\n  };\n\n  _f._closure = {};\n  _f.asString = \"function runAnimations(animation,timestamp,key,result,animationsActive){function runAnimations(animation,timestamp,key,result,animationsActive){if(!animationsActive.value){return true;}if(Array.isArray(animation)){result[key]=[];var allFinished=true;animation.forEach(function(entry,index){if(!runAnimations(entry,timestamp,index,result[key],animationsActive)){allFinished=false;}});return allFinished;}else if(typeof animation==='object'&&animation.onFrame){var finished=true;if(!animation.finished){if(animation.callStart){animation.callStart(timestamp);animation.callStart=null;}finished=animation.onFrame(animation,timestamp);animation.timestamp=timestamp;if(finished){animation.finished=true;animation.callback&&animation.callback(true);}}result[key]=animation.current;return finished;}else if(typeof animation==='object'){result[key]={};var _allFinished=true;Object.keys(animation).forEach(function(k){if(!runAnimations(animation[k],timestamp,k,result[key],animationsActive)){_allFinished=false;}});return _allFinished;}else{result[key]=animation;return true;}}return runAnimations(animation,timestamp,key,result,animationsActive);}\";\n  _f.__workletHash = 15750931731485;\n  _f.__location = \"C:\\\\Users\\\\a\\\\projects\\\\riders-app\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\Hooks.js (84:0)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nvar isAnimated = function () {\n  var _f = function _f(prop) {\n    function isAnimated(prop) {\n      if (Array.isArray(prop)) {\n        return prop.some(isAnimated);\n      }\n\n      if (typeof prop === 'object') {\n        if (prop.onFrame) {\n          return true;\n        }\n\n        return Object.keys(prop).some(function (key) {\n          return isAnimated(prop[key]);\n        });\n      }\n\n      return false;\n    }\n\n    return isAnimated(prop);\n  };\n\n  _f._closure = {};\n  _f.asString = \"function isAnimated(prop){function isAnimated(prop){if(Array.isArray(prop)){return prop.some(isAnimated);}if(typeof prop==='object'){if(prop.onFrame){return true;}return Object.keys(prop).some(function(key){return isAnimated(prop[key]);});}return false;}return isAnimated(prop);}\";\n  _f.__workletHash = 17049513327359;\n  _f.__location = \"C:\\\\Users\\\\a\\\\projects\\\\riders-app\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\Hooks.js (135:0)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nvar styleDiff = function () {\n  var _f = function _f(oldStyle, newStyle) {\n    var diff = {};\n    Object.keys(oldStyle).forEach(function (key) {\n      if (newStyle[key] === undefined) {\n        diff[key] = null;\n      }\n    });\n    Object.keys(newStyle).forEach(function (key) {\n      var value = newStyle[key];\n      var oldValue = oldStyle[key];\n\n      if (isAnimated(value)) {\n        return;\n      }\n\n      if (oldValue !== value && JSON.stringify(oldValue) !== JSON.stringify(value)) {\n        diff[key] = value;\n      }\n    });\n    return diff;\n  };\n\n  _f._closure = {\n    isAnimated: isAnimated\n  };\n  _f.asString = \"function styleDiff(oldStyle,newStyle){const{isAnimated}=jsThis._closure;{var diff={};Object.keys(oldStyle).forEach(function(key){if(newStyle[key]===undefined){diff[key]=null;}});Object.keys(newStyle).forEach(function(key){var value=newStyle[key];var oldValue=oldStyle[key];if(isAnimated(value)){return;}if(oldValue!==value&&JSON.stringify(oldValue)!==JSON.stringify(value)){diff[key]=value;}});return diff;}}\";\n  _f.__workletHash = 12547599973310;\n  _f.__location = \"C:\\\\Users\\\\a\\\\projects\\\\riders-app\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\Hooks.js (151:0)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nvar validateAnimatedStyles = function () {\n  var _f = function _f(styles) {\n    if (typeof styles !== 'object') {\n      throw new Error(\"useAnimatedStyle has to return an object, found \" + typeof styles + \" instead\");\n    } else if (Array.isArray(styles)) {\n      throw new Error('useAnimatedStyle has to return an object and cannot return static styles combined with dynamic ones. Please do merging where a component receives props.');\n    }\n  };\n\n  _f._closure = {};\n  _f.asString = \"function _f(styles){if(typeof styles!=='object'){throw new Error(\\\"useAnimatedStyle has to return an object, found \\\"+typeof styles+\\\" instead\\\");}else if(Array.isArray(styles)){throw new Error('useAnimatedStyle has to return an object and cannot return static styles combined with dynamic ones. Please do merging where a component receives props.');}}\";\n  _f.__workletHash = 316286613811;\n  _f.__location = \"C:\\\\Users\\\\a\\\\projects\\\\riders-app\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\Hooks.js (174:31)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nvar styleUpdater = function () {\n  var _f = function _f(viewDescriptor, updater, state, maybeViewRef, adapters, animationsActive) {\n    var animations = state.animations || {};\n    var newValues = updater() || {};\n    var oldValues = state.last;\n    var hasAnimations = false;\n    Object.keys(animations).forEach(function (key) {\n      var value = newValues[key];\n\n      if (!isAnimated(value)) {\n        delete animations[key];\n      }\n    });\n    Object.keys(newValues).forEach(function (key) {\n      var value = newValues[key];\n\n      if (isAnimated(value)) {\n        prepareAnimation(value, animations[key], oldValues[key]);\n        animations[key] = value;\n        hasAnimations = true;\n      }\n    });\n\n    function frame(timestamp) {\n      var animations = state.animations,\n          last = state.last,\n          isAnimationCancelled = state.isAnimationCancelled;\n\n      if (isAnimationCancelled) {\n        state.isAnimationRunning = false;\n        return;\n      }\n\n      var updates = {};\n      var allFinished = true;\n      Object.keys(animations).forEach(function (propName) {\n        var finished = runAnimations(animations[propName], timestamp, propName, updates, animationsActive);\n\n        if (finished) {\n          last[propName] = updates[propName];\n          delete animations[propName];\n        } else {\n          allFinished = false;\n        }\n      });\n\n      if (Object.keys(updates).length) {\n        (0, _UpdateProps.default)(viewDescriptor, updates, maybeViewRef, adapters);\n      }\n\n      if (!allFinished) {\n        (0, _core.requestFrame)(frame);\n      } else {\n        state.isAnimationRunning = false;\n      }\n    }\n\n    if (hasAnimations) {\n      state.animations = animations;\n\n      if (!state.isAnimationRunning) {\n        state.isAnimationCancelled = false;\n        state.isAnimationRunning = true;\n\n        if (_frameTimestamp) {\n          frame(_frameTimestamp);\n        } else {\n          (0, _core.requestFrame)(frame);\n        }\n      }\n    } else {\n      state.isAnimationCancelled = true;\n      state.animations = {};\n    }\n\n    var diff = styleDiff(oldValues, newValues);\n    state.last = Object.assign({}, oldValues, newValues);\n\n    if (Object.keys(diff).length !== 0) {\n      (0, _UpdateProps.default)(viewDescriptor, diff, maybeViewRef, adapters);\n    }\n  };\n\n  _f._closure = {\n    isAnimated: isAnimated,\n    prepareAnimation: prepareAnimation,\n    runAnimations: runAnimations,\n    updateProps: _UpdateProps.default,\n    requestFrame: _core.requestFrame,\n    styleDiff: styleDiff\n  };\n  _f.asString = \"function styleUpdater(viewDescriptor,updater,state,maybeViewRef,adapters,animationsActive){const{isAnimated,prepareAnimation,runAnimations,updateProps,requestFrame,styleDiff}=jsThis._closure;{var animations=state.animations||{};var newValues=updater()||{};var oldValues=state.last;var hasAnimations=false;Object.keys(animations).forEach(function(key){var value=newValues[key];if(!isAnimated(value)){delete animations[key];}});Object.keys(newValues).forEach(function(key){var value=newValues[key];if(isAnimated(value)){prepareAnimation(value,animations[key],oldValues[key]);animations[key]=value;hasAnimations=true;}});function frame(timestamp){var animations=state.animations,last=state.last,isAnimationCancelled=state.isAnimationCancelled;if(isAnimationCancelled){state.isAnimationRunning=false;return;}var updates={};var allFinished=true;Object.keys(animations).forEach(function(propName){var finished=runAnimations(animations[propName],timestamp,propName,updates,animationsActive);if(finished){last[propName]=updates[propName];delete animations[propName];}else{allFinished=false;}});if(Object.keys(updates).length){updateProps(viewDescriptor,updates,maybeViewRef,adapters);}if(!allFinished){requestFrame(frame);}else{state.isAnimationRunning=false;}}if(hasAnimations){state.animations=animations;if(!state.isAnimationRunning){state.isAnimationCancelled=false;state.isAnimationRunning=true;if(_frameTimestamp){frame(_frameTimestamp);}else{requestFrame(frame);}}}else{state.isAnimationCancelled=true;state.animations={};}var diff=styleDiff(oldValues,newValues);state.last=Object.assign({},oldValues,newValues);if(Object.keys(diff).length!==0){updateProps(viewDescriptor,diff,maybeViewRef,adapters);}}}\";\n  _f.__workletHash = 16147848788640;\n  _f.__location = \"C:\\\\Users\\\\a\\\\projects\\\\riders-app\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\Hooks.js (183:0)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nvar jestStyleUpdater = function () {\n  var _f = function _f(viewDescriptor, updater, state, maybeViewRef, adapters, animationsActive, animatedStyle) {\n    var animations = state.animations || {};\n    var newValues = updater() || {};\n    var oldValues = state.last;\n    var hasAnimations = false;\n    Object.keys(animations).forEach(function (key) {\n      var value = newValues[key];\n\n      if (!isAnimated(value)) {\n        delete animations[key];\n      }\n    });\n    Object.keys(newValues).forEach(function (key) {\n      var value = newValues[key];\n\n      if (isAnimated(value)) {\n        prepareAnimation(value, animations[key], oldValues[key]);\n        animations[key] = value;\n        hasAnimations = true;\n      }\n    });\n\n    function frame(timestamp) {\n      var animations = state.animations,\n          last = state.last,\n          isAnimationCancelled = state.isAnimationCancelled;\n\n      if (isAnimationCancelled) {\n        state.isAnimationRunning = false;\n        return;\n      }\n\n      var updates = {};\n      var allFinished = true;\n      Object.keys(animations).forEach(function (propName) {\n        var finished = runAnimations(animations[propName], timestamp, propName, updates, animationsActive);\n\n        if (finished) {\n          last[propName] = updates[propName];\n          delete animations[propName];\n        } else {\n          allFinished = false;\n        }\n      });\n\n      if (Object.keys(updates).length) {\n        (0, _UpdateProps.updatePropsJestWrapper)(viewDescriptor, updates, maybeViewRef, adapters, animatedStyle);\n      }\n\n      if (!allFinished) {\n        (0, _core.requestFrame)(frame);\n      } else {\n        state.isAnimationRunning = false;\n      }\n    }\n\n    if (hasAnimations) {\n      state.animations = animations;\n\n      if (!state.isAnimationRunning) {\n        state.isAnimationCancelled = false;\n        state.isAnimationRunning = true;\n\n        if (_frameTimestamp) {\n          frame(_frameTimestamp);\n        } else {\n          (0, _core.requestFrame)(frame);\n        }\n      }\n    } else {\n      state.isAnimationCancelled = true;\n      state.animations = {};\n    }\n\n    var diff = styleDiff(oldValues, newValues);\n    state.last = Object.assign({}, oldValues, newValues);\n\n    if (Object.keys(diff).length !== 0) {\n      (0, _UpdateProps.updatePropsJestWrapper)(viewDescriptor, diff, maybeViewRef, adapters, animatedStyle);\n    }\n  };\n\n  _f._closure = {\n    isAnimated: isAnimated,\n    prepareAnimation: prepareAnimation,\n    runAnimations: runAnimations,\n    updatePropsJestWrapper: _UpdateProps.updatePropsJestWrapper,\n    requestFrame: _core.requestFrame,\n    styleDiff: styleDiff\n  };\n  _f.asString = \"function jestStyleUpdater(viewDescriptor,updater,state,maybeViewRef,adapters,animationsActive,animatedStyle){const{isAnimated,prepareAnimation,runAnimations,updatePropsJestWrapper,requestFrame,styleDiff}=jsThis._closure;{var animations=state.animations||{};var newValues=updater()||{};var oldValues=state.last;var hasAnimations=false;Object.keys(animations).forEach(function(key){var value=newValues[key];if(!isAnimated(value)){delete animations[key];}});Object.keys(newValues).forEach(function(key){var value=newValues[key];if(isAnimated(value)){prepareAnimation(value,animations[key],oldValues[key]);animations[key]=value;hasAnimations=true;}});function frame(timestamp){var animations=state.animations,last=state.last,isAnimationCancelled=state.isAnimationCancelled;if(isAnimationCancelled){state.isAnimationRunning=false;return;}var updates={};var allFinished=true;Object.keys(animations).forEach(function(propName){var finished=runAnimations(animations[propName],timestamp,propName,updates,animationsActive);if(finished){last[propName]=updates[propName];delete animations[propName];}else{allFinished=false;}});if(Object.keys(updates).length){updatePropsJestWrapper(viewDescriptor,updates,maybeViewRef,adapters,animatedStyle);}if(!allFinished){requestFrame(frame);}else{state.isAnimationRunning=false;}}if(hasAnimations){state.animations=animations;if(!state.isAnimationRunning){state.isAnimationCancelled=false;state.isAnimationRunning=true;if(_frameTimestamp){frame(_frameTimestamp);}else{requestFrame(frame);}}}else{state.isAnimationCancelled=true;state.animations={};}var diff=styleDiff(oldValues,newValues);state.last=Object.assign({},oldValues,newValues);if(Object.keys(diff).length!==0){updatePropsJestWrapper(viewDescriptor,diff,maybeViewRef,adapters,animatedStyle);}}}\";\n  _f.__workletHash = 14563318023223;\n  _f.__location = \"C:\\\\Users\\\\a\\\\projects\\\\riders-app\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\Hooks.js (256:0)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nfunction useAnimatedStyle(updater, dependencies, adapters) {\n  var viewDescriptor = useSharedValue({\n    tag: -1,\n    name: null\n  }, false);\n  var initRef = (0, _react.useRef)(null);\n  var inputs = Object.values(updater._closure);\n  var viewRef = (0, _react.useRef)(null);\n  adapters = !adapters || Array.isArray(adapters) ? adapters : [adapters];\n  var adaptersHash = adapters ? buildWorkletsHash(adapters) : null;\n  var animationsActive = useSharedValue(true);\n  var animatedStyle;\n\n  if (process.env.JEST_WORKER_ID) {\n    animatedStyle = (0, _react.useRef)({});\n  }\n\n  if (!dependencies) {\n    dependencies = [].concat((0, _toConsumableArray2.default)(inputs), [updater.__workletHash]);\n  } else {\n    dependencies.push(updater.__workletHash);\n  }\n\n  adaptersHash && dependencies.push(adaptersHash);\n\n  if (initRef.current === null) {\n    var _initial = (0, _animations.initialUpdaterRun)(updater);\n\n    validateAnimatedStyles(_initial);\n    initRef.current = {\n      initial: _initial,\n      remoteState: (0, _core.makeRemote)({\n        last: _initial\n      })\n    };\n  }\n\n  var _initRef$current = initRef.current,\n      remoteState = _initRef$current.remoteState,\n      initial = _initRef$current.initial;\n  var maybeViewRef = _NativeReanimated.default.native ? undefined : viewRef;\n  (0, _react.useEffect)(function () {\n    var fun;\n\n    if (process.env.JEST_WORKER_ID) {\n      fun = function () {\n        var _f = function _f() {\n          jestStyleUpdater(viewDescriptor, updater, remoteState, maybeViewRef, adapters, animationsActive, animatedStyle);\n        };\n\n        _f._closure = {\n          jestStyleUpdater: jestStyleUpdater,\n          viewDescriptor: viewDescriptor,\n          updater: updater,\n          remoteState: remoteState,\n          maybeViewRef: maybeViewRef,\n          adapters: adapters,\n          animationsActive: animationsActive,\n          animatedStyle: animatedStyle\n        };\n        _f.asString = \"function _f(){const{jestStyleUpdater,viewDescriptor,updater,remoteState,maybeViewRef,adapters,animationsActive,animatedStyle}=jsThis._closure;{jestStyleUpdater(viewDescriptor,updater,remoteState,maybeViewRef,adapters,animationsActive,animatedStyle);}}\";\n        _f.__workletHash = 59913768497;\n        _f.__location = \"C:\\\\Users\\\\a\\\\projects\\\\riders-app\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\Hooks.js (362:18)\";\n\n        global.__reanimatedWorkletInit(_f);\n\n        return _f;\n      }();\n    } else {\n      fun = function () {\n        var _f = function _f() {\n          styleUpdater(viewDescriptor, updater, remoteState, maybeViewRef, adapters, animationsActive);\n        };\n\n        _f._closure = {\n          styleUpdater: styleUpdater,\n          viewDescriptor: viewDescriptor,\n          updater: updater,\n          remoteState: remoteState,\n          maybeViewRef: maybeViewRef,\n          adapters: adapters,\n          animationsActive: animationsActive\n        };\n        _f.asString = \"function _f(){const{styleUpdater,viewDescriptor,updater,remoteState,maybeViewRef,adapters,animationsActive}=jsThis._closure;{styleUpdater(viewDescriptor,updater,remoteState,maybeViewRef,adapters,animationsActive);}}\";\n        _f.__workletHash = 3563529919281;\n        _f.__location = \"C:\\\\Users\\\\a\\\\projects\\\\riders-app\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\Hooks.js (368:18)\";\n\n        global.__reanimatedWorkletInit(_f);\n\n        return _f;\n      }();\n    }\n\n    var mapperId = (0, _core.startMapper)(fun, inputs, []);\n    return function () {\n      (0, _core.stopMapper)(mapperId);\n    };\n  }, dependencies);\n  (0, _react.useEffect)(function () {\n    animationsActive.value = true;\n    return function () {\n      initRef.current = null;\n      viewRef.current = null;\n      animationsActive.value = false;\n    };\n  }, []);\n  var wrongKey;\n\n  var isObjectValid = function isObjectValid(element, key) {\n    var result = typeof element === 'object' && element.value !== undefined;\n\n    if (result) {\n      wrongKey = key;\n    }\n\n    return !result;\n  };\n\n  var isError = Object.keys(initial).some(function (key) {\n    var element = initial[key];\n    var result = false;\n\n    if (Array.isArray(element)) {\n      for (var _iterator = _createForOfIteratorHelperLoose(element), _step; !(_step = _iterator()).done;) {\n        var elementArrayItem = _step.value;\n\n        if (typeof elementArrayItem !== 'object') {\n          break;\n        }\n\n        var objectValue = Object.values(elementArrayItem)[0];\n        result = isObjectValid(objectValue, key);\n\n        if (!result) {\n          break;\n        }\n      }\n    } else {\n      result = isObjectValid(element, key);\n    }\n\n    return !result;\n  });\n\n  if (isError && wrongKey !== undefined) {\n    throw new Error(\"invalid value passed to `\" + wrongKey + \"`, maybe you forgot to use `.value`?\");\n  }\n\n  if (process.env.JEST_WORKER_ID) {\n    return {\n      viewDescriptor: viewDescriptor,\n      initial: initial,\n      viewRef: viewRef,\n      animatedStyle: animatedStyle\n    };\n  } else {\n    return {\n      viewDescriptor: viewDescriptor,\n      initial: initial,\n      viewRef: viewRef\n    };\n  }\n}\n\nvar useAnimatedProps = useAnimatedStyle;\nexports.useAnimatedProps = useAnimatedProps;\n\nfunction useDerivedValue(processor, dependencies) {\n  var initRef = (0, _react.useRef)(null);\n  var inputs = Object.values(processor._closure);\n\n  if (dependencies === undefined) {\n    dependencies = [].concat((0, _toConsumableArray2.default)(inputs), [processor.__workletHash]);\n  } else {\n    dependencies.push(processor.__workletHash);\n  }\n\n  if (initRef.current === null) {\n    initRef.current = (0, _core.makeMutable)((0, _animations.initialUpdaterRun)(processor));\n  }\n\n  var sharedValue = initRef.current;\n  (0, _react.useEffect)(function () {\n    var fun = function () {\n      var _f = function _f() {\n        sharedValue.value = processor();\n      };\n\n      _f._closure = {\n        sharedValue: sharedValue,\n        processor: processor\n      };\n      _f.asString = \"function _f(){const{sharedValue,processor}=jsThis._closure;{sharedValue.value=processor();}}\";\n      _f.__workletHash = 12308083001289;\n      _f.__location = \"C:\\\\Users\\\\a\\\\projects\\\\riders-app\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\Hooks.js (445:20)\";\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }();\n\n    var mapperId = (0, _core.startMapper)(fun, inputs, [sharedValue]);\n    return function () {\n      (0, _core.stopMapper)(mapperId);\n    };\n  }, dependencies);\n  (0, _react.useEffect)(function () {\n    return function () {\n      initRef.current = null;\n    };\n  }, []);\n  return sharedValue;\n}\n\nfunction buildWorkletsHash(handlers) {\n  return Object.keys(handlers).reduce(function (previousValue, key) {\n    return previousValue === null ? handlers[key].__workletHash : previousValue.toString() + handlers[key].__workletHash.toString();\n  }, null);\n}\n\nfunction buildDependencies(dependencies, handlers) {\n  if (!dependencies) {\n    dependencies = Object.keys(handlers).map(function (handlerKey) {\n      var handler = handlers[handlerKey];\n      return {\n        workletHash: handler.__workletHash,\n        closure: handler._closure\n      };\n    });\n  } else {\n    dependencies.push(buildWorkletsHash(handlers));\n  }\n\n  return dependencies;\n}\n\nfunction areDependenciesEqual(nextDeps, prevDeps) {\n  function is(x, y) {\n    return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;\n  }\n\n  var objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n  function areHookInputsEqual(nextDeps, prevDeps) {\n    if (!nextDeps || !prevDeps || prevDeps.length !== nextDeps.length) {\n      return false;\n    }\n\n    for (var i = 0; i < prevDeps.length; ++i) {\n      if (!objectIs(nextDeps[i], prevDeps[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return areHookInputsEqual(nextDeps, prevDeps);\n}\n\nfunction useAnimatedGestureHandler(handlers, dependencies) {\n  var initRef = (0, _react.useRef)(null);\n\n  if (initRef.current === null) {\n    initRef.current = {\n      context: (0, _core.makeRemote)({}),\n      savedDependencies: []\n    };\n  }\n\n  (0, _react.useEffect)(function () {\n    return function () {\n      initRef.current = null;\n    };\n  }, []);\n  var _initRef$current2 = initRef.current,\n      context = _initRef$current2.context,\n      savedDependencies = _initRef$current2.savedDependencies;\n  dependencies = buildDependencies(dependencies, handlers);\n  var dependenciesDiffer = !areDependenciesEqual(dependencies, savedDependencies);\n  initRef.current.savedDependencies = dependencies;\n\n  var handler = function () {\n    var _f = function _f(event) {\n      event = _reactNative.Platform.OS === 'web' ? event.nativeEvent : event;\n      var FAILED = 1;\n      var BEGAN = 2;\n      var CANCELLED = 3;\n      var ACTIVE = 4;\n      var END = 5;\n\n      if (event.state === BEGAN && handlers.onStart) {\n        handlers.onStart(event, context);\n      }\n\n      if (event.state === ACTIVE && handlers.onActive) {\n        handlers.onActive(event, context);\n      }\n\n      if (event.oldState === ACTIVE && event.state === END && handlers.onEnd) {\n        handlers.onEnd(event, context);\n      }\n\n      if (event.oldState === BEGAN && event.state === FAILED && handlers.onFail) {\n        handlers.onFail(event, context);\n      }\n\n      if (event.oldState === ACTIVE && event.state === CANCELLED && handlers.onCancel) {\n        handlers.onCancel(event, context);\n      }\n\n      if ((event.oldState === BEGAN || event.oldState === ACTIVE) && event.state !== BEGAN && event.state !== ACTIVE && handlers.onFinish) {\n        handlers.onFinish(event, context, event.state === CANCELLED || event.state === FAILED);\n      }\n    };\n\n    _f._closure = {\n      Platform: {\n        OS: _reactNative.Platform.OS\n      },\n      handlers: {\n        onStart: handlers.onStart,\n        onActive: handlers.onActive,\n        onEnd: handlers.onEnd,\n        onFail: handlers.onFail,\n        onCancel: handlers.onCancel,\n        onFinish: handlers.onFinish\n      },\n      context: context\n    };\n    _f.asString = \"function _f(event){const{Platform,handlers,context}=jsThis._closure;{event=Platform.OS==='web'?event.nativeEvent:event;var FAILED=1;var BEGAN=2;var CANCELLED=3;var ACTIVE=4;var END=5;if(event.state===BEGAN&&handlers.onStart){handlers.onStart(event,context);}if(event.state===ACTIVE&&handlers.onActive){handlers.onActive(event,context);}if(event.oldState===ACTIVE&&event.state===END&&handlers.onEnd){handlers.onEnd(event,context);}if(event.oldState===BEGAN&&event.state===FAILED&&handlers.onFail){handlers.onFail(event,context);}if(event.oldState===ACTIVE&&event.state===CANCELLED&&handlers.onCancel){handlers.onCancel(event,context);}if((event.oldState===BEGAN||event.oldState===ACTIVE)&&event.state!==BEGAN&&event.state!==ACTIVE&&handlers.onFinish){handlers.onFinish(event,context,event.state===CANCELLED||event.state===FAILED);}}}\";\n    _f.__workletHash = 11359316426451;\n    _f.__location = \"C:\\\\Users\\\\a\\\\projects\\\\riders-app\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\Hooks.js (521:20)\";\n\n    global.__reanimatedWorkletInit(_f);\n\n    return _f;\n  }();\n\n  if (_reactNative.Platform.OS === 'web') {\n    return handler;\n  }\n\n  return useEvent(handler, ['onGestureHandlerStateChange', 'onGestureHandlerEvent'], dependenciesDiffer);\n}\n\nfunction useAnimatedScrollHandler(handlers, dependencies) {\n  var initRef = (0, _react.useRef)(null);\n\n  if (initRef.current === null) {\n    initRef.current = {\n      context: (0, _core.makeRemote)({}),\n      savedDependencies: []\n    };\n  }\n\n  (0, _react.useEffect)(function () {\n    return function () {\n      initRef.current = null;\n    };\n  }, []);\n  var _initRef$current3 = initRef.current,\n      context = _initRef$current3.context,\n      savedDependencies = _initRef$current3.savedDependencies;\n  dependencies = buildDependencies(dependencies, handlers);\n  var dependenciesDiffer = !areDependenciesEqual(dependencies, savedDependencies);\n  initRef.current.savedDependencies = dependencies;\n  var subscribeForEvents = ['onScroll'];\n\n  if (handlers.onBeginDrag !== undefined) {\n    subscribeForEvents.push('onScrollBeginDrag');\n  }\n\n  if (handlers.onEndDrag !== undefined) {\n    subscribeForEvents.push('onScrollEndDrag');\n  }\n\n  if (handlers.onMomentumBegin !== undefined) {\n    subscribeForEvents.push('onMomentumScrollBegin');\n  }\n\n  if (handlers.onMomentumEnd !== undefined) {\n    subscribeForEvents.push('onMomentumScrollEnd');\n  }\n\n  return useEvent(function () {\n    var _f = function _f(event) {\n      var onScroll = handlers.onScroll,\n          onBeginDrag = handlers.onBeginDrag,\n          onEndDrag = handlers.onEndDrag,\n          onMomentumBegin = handlers.onMomentumBegin,\n          onMomentumEnd = handlers.onMomentumEnd;\n\n      if (event.eventName.endsWith('onScroll')) {\n        if (onScroll) {\n          onScroll(event, context);\n        } else if (typeof handlers === 'function') {\n          handlers(event, context);\n        }\n      } else if (onBeginDrag && event.eventName.endsWith('onScrollBeginDrag')) {\n        onBeginDrag(event, context);\n      } else if (onEndDrag && event.eventName.endsWith('onScrollEndDrag')) {\n        onEndDrag(event, context);\n      } else if (onMomentumBegin && event.eventName.endsWith('onMomentumScrollBegin')) {\n        onMomentumBegin(event, context);\n      } else if (onMomentumEnd && event.eventName.endsWith('onMomentumScrollEnd')) {\n        onMomentumEnd(event, context);\n      }\n    };\n\n    _f._closure = {\n      handlers: handlers,\n      context: context\n    };\n    _f.asString = \"function _f(event){const{handlers,context}=jsThis._closure;{var onScroll=handlers.onScroll,onBeginDrag=handlers.onBeginDrag,onEndDrag=handlers.onEndDrag,onMomentumBegin=handlers.onMomentumBegin,onMomentumEnd=handlers.onMomentumEnd;if(event.eventName.endsWith('onScroll')){if(onScroll){onScroll(event,context);}else if(typeof handlers==='function'){handlers(event,context);}}else if(onBeginDrag&&event.eventName.endsWith('onScrollBeginDrag')){onBeginDrag(event,context);}else if(onEndDrag&&event.eventName.endsWith('onScrollEndDrag')){onEndDrag(event,context);}else if(onMomentumBegin&&event.eventName.endsWith('onMomentumScrollBegin')){onMomentumBegin(event,context);}else if(onMomentumEnd&&event.eventName.endsWith('onMomentumScrollEnd')){onMomentumEnd(event,context);}}}\";\n    _f.__workletHash = 8464190533272;\n    _f.__location = \"C:\\\\Users\\\\a\\\\projects\\\\riders-app\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\Hooks.js (589:20)\";\n\n    global.__reanimatedWorkletInit(_f);\n\n    return _f;\n  }(), subscribeForEvents, dependenciesDiffer);\n}\n\nfunction useAnimatedRef() {\n  var tag = useSharedValue(-1);\n  var ref = (0, _react.useRef)(null);\n\n  if (!ref.current) {\n    var fun = function () {\n      var _f = function _f(component) {\n        if (component) {\n          tag.value = (0, _NativeMethods.getTag)(component);\n          fun.current = component;\n        }\n\n        return tag.value;\n      };\n\n      _f._closure = {\n        tag: tag,\n        getTag: _NativeMethods.getTag,\n        fun: fun\n      };\n      _f.asString = \"function _f(component){const{tag,getTag,fun}=jsThis._closure;{if(component){tag.value=getTag(component);fun.current=component;}return tag.value;}}\";\n      _f.__workletHash = 2837072662922;\n      _f.__location = \"C:\\\\Users\\\\a\\\\projects\\\\riders-app\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\Hooks.js (620:20)\";\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }();\n\n    Object.defineProperty(fun, 'current', {\n      value: null,\n      writable: true,\n      enumerable: false\n    });\n    ref.current = fun;\n  }\n\n  return ref.current;\n}\n\nfunction useAnimatedReaction(prepare, react, dependencies) {\n  var previous = useSharedValue(null);\n\n  if (dependencies === undefined) {\n    dependencies = [Object.values(prepare._closure), Object.values(react._closure), prepare.__workletHash, react.__workletHash];\n  } else {\n    dependencies.push(prepare.__workletHash, react.__workletHash);\n  }\n\n  (0, _react.useEffect)(function () {\n    var fun = function () {\n      var _f = function _f() {\n        var input = prepare();\n        react(input, previous.value);\n        previous.value = input;\n      };\n\n      _f._closure = {\n        prepare: prepare,\n        react: react,\n        previous: previous\n      };\n      _f.asString = \"function _f(){const{prepare,react,previous}=jsThis._closure;{var input=prepare();react(input,previous.value);previous.value=input;}}\";\n      _f.__workletHash = 8277443003666;\n      _f.__location = \"C:\\\\Users\\\\a\\\\projects\\\\riders-app\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\Hooks.js (658:20)\";\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }();\n\n    var mapperId = (0, _core.startMapper)(fun, Object.values(prepare._closure), []);\n    return function () {\n      (0, _core.stopMapper)(mapperId);\n    };\n  }, dependencies);\n}\n\nfunction useWorkletCallback(fun, deps) {\n  return (0, _react.useCallback)(fun, deps);\n}\n\nfunction createWorklet(fun) {\n  return fun;\n}",
  "map": {
    "version": 3,
    "sources": [
      "C:/Users/a/projects/riders-app/node_modules/react-native-reanimated/lib/reanimated2/Hooks.js"
    ],
    "names": [
      "useSharedValue",
      "init",
      "ref",
      "current",
      "useEvent",
      "handler",
      "eventNames",
      "rebuild",
      "initRef",
      "WorkletEventHandler",
      "updateWorklet",
      "prepareAnimation",
      "animatedProp",
      "lastAnimation",
      "lastValue",
      "Array",
      "isArray",
      "forEach",
      "prop",
      "index",
      "onFrame",
      "animation",
      "value",
      "undefined",
      "callStart",
      "timestamp",
      "onStart",
      "Object",
      "keys",
      "key",
      "getTimestamp",
      "runAnimations",
      "result",
      "animationsActive",
      "allFinished",
      "entry",
      "finished",
      "callback",
      "k",
      "isAnimated",
      "some",
      "styleDiff",
      "oldStyle",
      "newStyle",
      "diff",
      "oldValue",
      "JSON",
      "stringify",
      "validateAnimatedStyles",
      "styles",
      "Error",
      "styleUpdater",
      "viewDescriptor",
      "updater",
      "state",
      "maybeViewRef",
      "adapters",
      "animations",
      "newValues",
      "oldValues",
      "last",
      "hasAnimations",
      "frame",
      "isAnimationCancelled",
      "isAnimationRunning",
      "updates",
      "propName",
      "length",
      "_frameTimestamp",
      "assign",
      "updateProps",
      "requestFrame",
      "jestStyleUpdater",
      "animatedStyle",
      "updatePropsJestWrapper",
      "useAnimatedStyle",
      "dependencies",
      "tag",
      "name",
      "inputs",
      "values",
      "_closure",
      "viewRef",
      "adaptersHash",
      "buildWorkletsHash",
      "process",
      "env",
      "JEST_WORKER_ID",
      "__workletHash",
      "push",
      "initial",
      "remoteState",
      "NativeReanimated",
      "native",
      "fun",
      "mapperId",
      "wrongKey",
      "isObjectValid",
      "element",
      "isError",
      "elementArrayItem",
      "objectValue",
      "useAnimatedProps",
      "useDerivedValue",
      "processor",
      "sharedValue",
      "handlers",
      "reduce",
      "previousValue",
      "toString",
      "buildDependencies",
      "map",
      "handlerKey",
      "workletHash",
      "closure",
      "areDependenciesEqual",
      "nextDeps",
      "prevDeps",
      "is",
      "x",
      "y",
      "objectIs",
      "areHookInputsEqual",
      "i",
      "useAnimatedGestureHandler",
      "context",
      "savedDependencies",
      "dependenciesDiffer",
      "event",
      "Platform",
      "OS",
      "nativeEvent",
      "FAILED",
      "BEGAN",
      "CANCELLED",
      "ACTIVE",
      "END",
      "onActive",
      "oldState",
      "onEnd",
      "onFail",
      "onCancel",
      "onFinish",
      "useAnimatedScrollHandler",
      "subscribeForEvents",
      "onBeginDrag",
      "onEndDrag",
      "onMomentumBegin",
      "onMomentumEnd",
      "onScroll",
      "eventName",
      "endsWith",
      "useAnimatedRef",
      "component",
      "getTag",
      "defineProperty",
      "writable",
      "enumerable",
      "useAnimatedReaction",
      "prepare",
      "react",
      "previous",
      "input",
      "useWorkletCallback",
      "deps",
      "createWorklet"
    ],
    "mappings": ";;;;;;;;;;;;;;;;;;;AAGA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;;;;;AACO,SAASA,cAAT,CAAwBC,IAAxB,EAA8B;AACjC,MAAMC,GAAG,GAAG,mBAAO,IAAP,CAAZ;;AACA,MAAIA,GAAG,CAACC,OAAJ,KAAgB,IAApB,EAA0B;AACtBD,IAAAA,GAAG,CAACC,OAAJ,GAAc,uBAAYF,IAAZ,CAAd;AACH;;AACD,wBAAU,YAAM;AACZ,WAAO,YAAM;AACT,uCAAgBC,GAAG,CAACC,OAApB;AACH,KAFD;AAGH,GAJD,EAIG,EAJH;AAKA,SAAOD,GAAG,CAACC,OAAX;AACH;;AACM,SAASC,QAAT,CAAkBC,OAAlB,EAA6D;AAAA,MAAlCC,UAAkC,uEAArB,EAAqB;AAAA,MAAjBC,OAAiB,uEAAP,KAAO;AAChE,MAAMC,OAAO,GAAG,mBAAO,IAAP,CAAhB;;AACA,MAAIA,OAAO,CAACL,OAAR,KAAoB,IAAxB,EAA8B;AAC1BK,IAAAA,OAAO,CAACL,OAAR,GAAkB,IAAIM,4BAAJ,CAAwBJ,OAAxB,EAAiCC,UAAjC,CAAlB;AACH,GAFD,MAGK,IAAIC,OAAJ,EAAa;AACdC,IAAAA,OAAO,CAACL,OAAR,CAAgBO,aAAhB,CAA8BL,OAA9B;AACH;;AACD,wBAAU,YAAM;AACZ,WAAO,YAAM;AACTG,MAAAA,OAAO,CAACL,OAAR,GAAkB,IAAlB;AACH,KAFD;AAGH,GAJD,EAIG,EAJH;AAKA,SAAOK,OAAP;AACH;;IACQG,gB;uBAAiBC,Y,EAAcC,a,EAAeC,S,EAAW;AAE9D,aAASH,gBAAT,CAA0BC,YAA1B,EAAwCC,aAAxC,EAAuDC,SAAvD,EAAkE;AAC9D,UAAIC,KAAK,CAACC,OAAN,CAAcJ,YAAd,CAAJ,EAAiC;AAC7BA,QAAAA,YAAY,CAACK,OAAb,CAAqB,UAACC,IAAD,EAAOC,KAAP;AAAA,iBAAiBR,gBAAgB,CAACO,IAAD,EAAOL,aAAa,IAAIA,aAAa,CAACM,KAAD,CAArC,EAA8CL,SAAS,IAAIA,SAAS,CAACK,KAAD,CAApE,CAAjC;AAAA,SAArB;AACA,eAAOP,YAAP;AACH;;AACD,UAAI,OAAOA,YAAP,KAAwB,QAAxB,IAAoCA,YAAY,CAACQ,OAArD,EAA8D;AAC1D,YAAMC,SAAS,GAAGT,YAAlB;AACA,YAAIU,KAAK,GAAGD,SAAS,CAAClB,OAAtB;;AACA,YAAIW,SAAS,KAAKS,SAAlB,EAA6B;AACzB,cAAI,OAAOT,SAAP,KAAqB,QAAzB,EAAmC;AAC/B,gBAAIA,SAAS,CAACQ,KAAV,KAAoBC,SAAxB,EAAmC;AAE/BD,cAAAA,KAAK,GAAGR,SAAS,CAACQ,KAAlB;AACH,aAHD,MAIK,IAAIR,SAAS,CAACM,OAAV,KAAsBG,SAA1B,EAAqC;AACtC,kBAAI,CAACV,aAAa,KAAK,IAAlB,IAA0BA,aAAa,KAAK,KAAK,CAAjD,GAAqD,KAAK,CAA1D,GAA8DA,aAAa,CAACV,OAA7E,MAA0FoB,SAA9F,EAAyG;AAErGD,gBAAAA,KAAK,GAAGT,aAAa,CAACV,OAAtB;AACH,eAHD,MAIK,IAAI,CAACW,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAK,KAAK,CAAzC,GAA6C,KAAK,CAAlD,GAAsDA,SAAS,CAACX,OAAjE,MAA8EoB,SAAlF,EAA6F;AAE9FD,gBAAAA,KAAK,GAAGR,SAAS,CAACX,OAAlB;AACH;AACJ;AACJ,WAfD,MAgBK;AAEDmB,YAAAA,KAAK,GAAGR,SAAR;AACH;AACJ;;AACDO,QAAAA,SAAS,CAACG,SAAV,GAAsB,UAACC,SAAD,EAAe;AACjCJ,UAAAA,SAAS,CAACK,OAAV,CAAkBL,SAAlB,EAA6BC,KAA7B,EAAoCG,SAApC,EAA+CZ,aAA/C;AACH,SAFD;;AAGAQ,QAAAA,SAAS,CAACG,SAAV,CAAoB,yBAApB;AACAH,QAAAA,SAAS,CAACG,SAAV,GAAsB,IAAtB;AACH,OA9BD,MA+BK,IAAI,OAAOZ,YAAP,KAAwB,QAA5B,EAAsC;AAEvCe,QAAAA,MAAM,CAACC,IAAP,CAAYhB,YAAZ,EAA0BK,OAA1B,CAAkC,UAACY,GAAD;AAAA,iBAASlB,gBAAgB,CAACC,YAAY,CAACiB,GAAD,CAAb,EAAoBhB,aAAa,IAAIA,aAAa,CAACgB,GAAD,CAAlD,EAAyDf,SAAS,IAAIA,SAAS,CAACe,GAAD,CAA/E,CAAzB;AAAA,SAAlC;AACH;AACJ;;AACD,WAAOlB,gBAAgB,CAACC,YAAD,EAAeC,aAAf,EAA8BC,SAA9B,CAAvB;AACH,G;;;kBA1CyBgB;;;;;;;;;;;IA2CjBC,a;uBAAcV,S,EAAWI,S,EAAWI,G,EAAKG,M,EAAQC,gB,EAAkB;AAExE,aAASF,aAAT,CAAuBV,SAAvB,EAAkCI,SAAlC,EAA6CI,GAA7C,EAAkDG,MAAlD,EAA0DC,gBAA1D,EAA4E;AACxE,UAAI,CAACA,gBAAgB,CAACX,KAAtB,EAA6B;AACzB,eAAO,IAAP;AACH;;AACD,UAAIP,KAAK,CAACC,OAAN,CAAcK,SAAd,CAAJ,EAA8B;AAC1BW,QAAAA,MAAM,CAACH,GAAD,CAAN,GAAc,EAAd;AACA,YAAIK,WAAW,GAAG,IAAlB;AACAb,QAAAA,SAAS,CAACJ,OAAV,CAAkB,UAACkB,KAAD,EAAQhB,KAAR,EAAkB;AAChC,cAAI,CAACY,aAAa,CAACI,KAAD,EAAQV,SAAR,EAAmBN,KAAnB,EAA0Ba,MAAM,CAACH,GAAD,CAAhC,EAAuCI,gBAAvC,CAAlB,EAA4E;AACxEC,YAAAA,WAAW,GAAG,KAAd;AACH;AACJ,SAJD;AAKA,eAAOA,WAAP;AACH,OATD,MAUK,IAAI,OAAOb,SAAP,KAAqB,QAArB,IAAiCA,SAAS,CAACD,OAA/C,EAAwD;AACzD,YAAIgB,QAAQ,GAAG,IAAf;;AACA,YAAI,CAACf,SAAS,CAACe,QAAf,EAAyB;AACrB,cAAIf,SAAS,CAACG,SAAd,EAAyB;AACrBH,YAAAA,SAAS,CAACG,SAAV,CAAoBC,SAApB;AACAJ,YAAAA,SAAS,CAACG,SAAV,GAAsB,IAAtB;AACH;;AACDY,UAAAA,QAAQ,GAAGf,SAAS,CAACD,OAAV,CAAkBC,SAAlB,EAA6BI,SAA7B,CAAX;AACAJ,UAAAA,SAAS,CAACI,SAAV,GAAsBA,SAAtB;;AACA,cAAIW,QAAJ,EAAc;AACVf,YAAAA,SAAS,CAACe,QAAV,GAAqB,IAArB;AACAf,YAAAA,SAAS,CAACgB,QAAV,IAAsBhB,SAAS,CAACgB,QAAV,CAAmB,IAAnB,CAAtB;AACH;AACJ;;AACDL,QAAAA,MAAM,CAACH,GAAD,CAAN,GAAcR,SAAS,CAAClB,OAAxB;AACA,eAAOiC,QAAP;AACH,OAhBI,MAiBA,IAAI,OAAOf,SAAP,KAAqB,QAAzB,EAAmC;AACpCW,QAAAA,MAAM,CAACH,GAAD,CAAN,GAAc,EAAd;AACA,YAAIK,YAAW,GAAG,IAAlB;AACAP,QAAAA,MAAM,CAACC,IAAP,CAAYP,SAAZ,EAAuBJ,OAAvB,CAA+B,UAACqB,CAAD,EAAO;AAClC,cAAI,CAACP,aAAa,CAACV,SAAS,CAACiB,CAAD,CAAV,EAAeb,SAAf,EAA0Ba,CAA1B,EAA6BN,MAAM,CAACH,GAAD,CAAnC,EAA0CI,gBAA1C,CAAlB,EAA+E;AAC3EC,YAAAA,YAAW,GAAG,KAAd;AACH;AACJ,SAJD;AAKA,eAAOA,YAAP;AACH,OATI,MAUA;AACDF,QAAAA,MAAM,CAACH,GAAD,CAAN,GAAcR,SAAd;AACA,eAAO,IAAP;AACH;AACJ;;AACD,WAAOU,aAAa,CAACV,SAAD,EAAYI,SAAZ,EAAuBI,GAAvB,EAA4BG,MAA5B,EAAoCC,gBAApC,CAApB;AACH,G;;;;;;;;;;;;IAEQM,U;uBAAWrB,I,EAAM;AAEtB,aAASqB,UAAT,CAAoBrB,IAApB,EAA0B;AACtB,UAAIH,KAAK,CAACC,OAAN,CAAcE,IAAd,CAAJ,EAAyB;AACrB,eAAOA,IAAI,CAACsB,IAAL,CAAUD,UAAV,CAAP;AACH;;AACD,UAAI,OAAOrB,IAAP,KAAgB,QAApB,EAA8B;AAC1B,YAAIA,IAAI,CAACE,OAAT,EAAkB;AACd,iBAAO,IAAP;AACH;;AACD,eAAOO,MAAM,CAACC,IAAP,CAAYV,IAAZ,EAAkBsB,IAAlB,CAAuB,UAACX,GAAD;AAAA,iBAASU,UAAU,CAACrB,IAAI,CAACW,GAAD,CAAL,CAAnB;AAAA,SAAvB,CAAP;AACH;;AACD,aAAO,KAAP;AACH;;AACD,WAAOU,UAAU,CAACrB,IAAD,CAAjB;AACH,G;;;;;;;;;;;;IACQuB,S;uBAAUC,Q,EAAUC,Q,EAAU;AAEnC,QAAMC,IAAI,GAAG,EAAb;AACAjB,IAAAA,MAAM,CAACC,IAAP,CAAYc,QAAZ,EAAsBzB,OAAtB,CAA8B,UAACY,GAAD,EAAS;AACnC,UAAIc,QAAQ,CAACd,GAAD,CAAR,KAAkBN,SAAtB,EAAiC;AAC7BqB,QAAAA,IAAI,CAACf,GAAD,CAAJ,GAAY,IAAZ;AACH;AACJ,KAJD;AAKAF,IAAAA,MAAM,CAACC,IAAP,CAAYe,QAAZ,EAAsB1B,OAAtB,CAA8B,UAACY,GAAD,EAAS;AACnC,UAAMP,KAAK,GAAGqB,QAAQ,CAACd,GAAD,CAAtB;AACA,UAAMgB,QAAQ,GAAGH,QAAQ,CAACb,GAAD,CAAzB;;AACA,UAAIU,UAAU,CAACjB,KAAD,CAAd,EAAuB;AAEnB;AACH;;AACD,UAAIuB,QAAQ,KAAKvB,KAAb,IACAwB,IAAI,CAACC,SAAL,CAAeF,QAAf,MAA6BC,IAAI,CAACC,SAAL,CAAezB,KAAf,CADjC,EACwD;AAEpDsB,QAAAA,IAAI,CAACf,GAAD,CAAJ,GAAYP,KAAZ;AACH;AACJ,KAZD;AAaA,WAAOsB,IAAP;AACH,G;;;gBA9JOL;;;;;;;;;;;AA+JR,IAAMS,sBAAsB;AAAA,uBAAIC,MAAJ,EAAe;AAEvC,QAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;AAC5B,YAAM,IAAIC,KAAJ,sDAA6D,OAAOD,MAApE,cAAN;AACH,KAFD,MAGK,IAAIlC,KAAK,CAACC,OAAN,CAAciC,MAAd,CAAJ,EAA2B;AAC5B,YAAM,IAAIC,KAAJ,CAAU,0JAAV,CAAN;AACH;AACJ,GAR2B;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA,GAA5B;;IASSC,Y;uBAAaC,c,EAAgBC,O,EAASC,K,EAAOC,Y,EAAcC,Q,EAAUvB,gB,EAAkB;AAE5F,QAAMwB,UAAU,GAAGH,KAAK,CAACG,UAAN,IAAoB,EAAvC;AACA,QAAMC,SAAS,GAAGL,OAAO,MAAM,EAA/B;AACA,QAAMM,SAAS,GAAGL,KAAK,CAACM,IAAxB;AAEA,QAAIC,aAAa,GAAG,KAApB;AACAlC,IAAAA,MAAM,CAACC,IAAP,CAAY6B,UAAZ,EAAwBxC,OAAxB,CAAgC,UAACY,GAAD,EAAS;AACrC,UAAMP,KAAK,GAAGoC,SAAS,CAAC7B,GAAD,CAAvB;;AACA,UAAI,CAACU,UAAU,CAACjB,KAAD,CAAf,EAAwB;AACpB,eAAOmC,UAAU,CAAC5B,GAAD,CAAjB;AACH;AACJ,KALD;AAMAF,IAAAA,MAAM,CAACC,IAAP,CAAY8B,SAAZ,EAAuBzC,OAAvB,CAA+B,UAACY,GAAD,EAAS;AACpC,UAAMP,KAAK,GAAGoC,SAAS,CAAC7B,GAAD,CAAvB;;AACA,UAAIU,UAAU,CAACjB,KAAD,CAAd,EAAuB;AACnBX,QAAAA,gBAAgB,CAACW,KAAD,EAAQmC,UAAU,CAAC5B,GAAD,CAAlB,EAAyB8B,SAAS,CAAC9B,GAAD,CAAlC,CAAhB;AACA4B,QAAAA,UAAU,CAAC5B,GAAD,CAAV,GAAkBP,KAAlB;AACAuC,QAAAA,aAAa,GAAG,IAAhB;AACH;AACJ,KAPD;;AAQA,aAASC,KAAT,CAAerC,SAAf,EAA0B;AACtB,UAAQgC,UAAR,GAAmDH,KAAnD,CAAQG,UAAR;AAAA,UAAoBG,IAApB,GAAmDN,KAAnD,CAAoBM,IAApB;AAAA,UAA0BG,oBAA1B,GAAmDT,KAAnD,CAA0BS,oBAA1B;;AACA,UAAIA,oBAAJ,EAA0B;AACtBT,QAAAA,KAAK,CAACU,kBAAN,GAA2B,KAA3B;AACA;AACH;;AACD,UAAMC,OAAO,GAAG,EAAhB;AACA,UAAI/B,WAAW,GAAG,IAAlB;AACAP,MAAAA,MAAM,CAACC,IAAP,CAAY6B,UAAZ,EAAwBxC,OAAxB,CAAgC,UAACiD,QAAD,EAAc;AAC1C,YAAM9B,QAAQ,GAAGL,aAAa,CAAC0B,UAAU,CAACS,QAAD,CAAX,EAAuBzC,SAAvB,EAAkCyC,QAAlC,EAA4CD,OAA5C,EAAqDhC,gBAArD,CAA9B;;AACA,YAAIG,QAAJ,EAAc;AACVwB,UAAAA,IAAI,CAACM,QAAD,CAAJ,GAAiBD,OAAO,CAACC,QAAD,CAAxB;AACA,iBAAOT,UAAU,CAACS,QAAD,CAAjB;AACH,SAHD,MAIK;AACDhC,UAAAA,WAAW,GAAG,KAAd;AACH;AACJ,OATD;;AAUA,UAAIP,MAAM,CAACC,IAAP,CAAYqC,OAAZ,EAAqBE,MAAzB,EAAiC;AAC7B,kCAAYf,cAAZ,EAA4Ba,OAA5B,EAAqCV,YAArC,EAAmDC,QAAnD;AACH;;AACD,UAAI,CAACtB,WAAL,EAAkB;AACd,gCAAa4B,KAAb;AACH,OAFD,MAGK;AACDR,QAAAA,KAAK,CAACU,kBAAN,GAA2B,KAA3B;AACH;AACJ;;AACD,QAAIH,aAAJ,EAAmB;AACfP,MAAAA,KAAK,CAACG,UAAN,GAAmBA,UAAnB;;AACA,UAAI,CAACH,KAAK,CAACU,kBAAX,EAA+B;AAC3BV,QAAAA,KAAK,CAACS,oBAAN,GAA6B,KAA7B;AACAT,QAAAA,KAAK,CAACU,kBAAN,GAA2B,IAA3B;;AACA,YAAII,eAAJ,EAAqB;AACjBN,UAAAA,KAAK,CAACM,eAAD,CAAL;AACH,SAFD,MAGK;AACD,kCAAaN,KAAb;AACH;AACJ;AACJ,KAZD,MAaK;AACDR,MAAAA,KAAK,CAACS,oBAAN,GAA6B,IAA7B;AACAT,MAAAA,KAAK,CAACG,UAAN,GAAmB,EAAnB;AACH;;AAED,QAAMb,IAAI,GAAGH,SAAS,CAACkB,SAAD,EAAYD,SAAZ,CAAtB;AACAJ,IAAAA,KAAK,CAACM,IAAN,GAAajC,MAAM,CAAC0C,MAAP,CAAc,EAAd,EAAkBV,SAAlB,EAA6BD,SAA7B,CAAb;;AACA,QAAI/B,MAAM,CAACC,IAAP,CAAYgB,IAAZ,EAAkBuB,MAAlB,KAA6B,CAAjC,EAAoC;AAChC,gCAAYf,cAAZ,EAA4BR,IAA5B,EAAkCW,YAAlC,EAAgDC,QAAhD;AACH;AACJ,G;;;gBA3OOjB,U;sBACF5B,gB;mBAmBeoB,a;iBA4CjBuC,oB;kBAbIC,kB;eASK9B;;;;;;;;;;;IAgLJ+B,gB;uBAAiBpB,c,EAAgBC,O,EAASC,K,EAAOC,Y,EAAcC,Q,EAAUvB,gB,EAAkBwC,a,EAAe;AAE/G,QAAMhB,UAAU,GAAGH,KAAK,CAACG,UAAN,IAAoB,EAAvC;AACA,QAAMC,SAAS,GAAGL,OAAO,MAAM,EAA/B;AACA,QAAMM,SAAS,GAAGL,KAAK,CAACM,IAAxB;AAEA,QAAIC,aAAa,GAAG,KAApB;AACAlC,IAAAA,MAAM,CAACC,IAAP,CAAY6B,UAAZ,EAAwBxC,OAAxB,CAAgC,UAACY,GAAD,EAAS;AACrC,UAAMP,KAAK,GAAGoC,SAAS,CAAC7B,GAAD,CAAvB;;AACA,UAAI,CAACU,UAAU,CAACjB,KAAD,CAAf,EAAwB;AACpB,eAAOmC,UAAU,CAAC5B,GAAD,CAAjB;AACH;AACJ,KALD;AAMAF,IAAAA,MAAM,CAACC,IAAP,CAAY8B,SAAZ,EAAuBzC,OAAvB,CAA+B,UAACY,GAAD,EAAS;AACpC,UAAMP,KAAK,GAAGoC,SAAS,CAAC7B,GAAD,CAAvB;;AACA,UAAIU,UAAU,CAACjB,KAAD,CAAd,EAAuB;AACnBX,QAAAA,gBAAgB,CAACW,KAAD,EAAQmC,UAAU,CAAC5B,GAAD,CAAlB,EAAyB8B,SAAS,CAAC9B,GAAD,CAAlC,CAAhB;AACA4B,QAAAA,UAAU,CAAC5B,GAAD,CAAV,GAAkBP,KAAlB;AACAuC,QAAAA,aAAa,GAAG,IAAhB;AACH;AACJ,KAPD;;AAQA,aAASC,KAAT,CAAerC,SAAf,EAA0B;AACtB,UAAQgC,UAAR,GAAmDH,KAAnD,CAAQG,UAAR;AAAA,UAAoBG,IAApB,GAAmDN,KAAnD,CAAoBM,IAApB;AAAA,UAA0BG,oBAA1B,GAAmDT,KAAnD,CAA0BS,oBAA1B;;AACA,UAAIA,oBAAJ,EAA0B;AACtBT,QAAAA,KAAK,CAACU,kBAAN,GAA2B,KAA3B;AACA;AACH;;AACD,UAAMC,OAAO,GAAG,EAAhB;AACA,UAAI/B,WAAW,GAAG,IAAlB;AACAP,MAAAA,MAAM,CAACC,IAAP,CAAY6B,UAAZ,EAAwBxC,OAAxB,CAAgC,UAACiD,QAAD,EAAc;AAC1C,YAAM9B,QAAQ,GAAGL,aAAa,CAAC0B,UAAU,CAACS,QAAD,CAAX,EAAuBzC,SAAvB,EAAkCyC,QAAlC,EAA4CD,OAA5C,EAAqDhC,gBAArD,CAA9B;;AACA,YAAIG,QAAJ,EAAc;AACVwB,UAAAA,IAAI,CAACM,QAAD,CAAJ,GAAiBD,OAAO,CAACC,QAAD,CAAxB;AACA,iBAAOT,UAAU,CAACS,QAAD,CAAjB;AACH,SAHD,MAIK;AACDhC,UAAAA,WAAW,GAAG,KAAd;AACH;AACJ,OATD;;AAUA,UAAIP,MAAM,CAACC,IAAP,CAAYqC,OAAZ,EAAqBE,MAAzB,EAAiC;AAC7B,iDAAuBf,cAAvB,EAAuCa,OAAvC,EAAgDV,YAAhD,EAA8DC,QAA9D,EAAwEiB,aAAxE;AACH;;AACD,UAAI,CAACvC,WAAL,EAAkB;AACd,gCAAa4B,KAAb;AACH,OAFD,MAGK;AACDR,QAAAA,KAAK,CAACU,kBAAN,GAA2B,KAA3B;AACH;AACJ;;AACD,QAAIH,aAAJ,EAAmB;AACfP,MAAAA,KAAK,CAACG,UAAN,GAAmBA,UAAnB;;AACA,UAAI,CAACH,KAAK,CAACU,kBAAX,EAA+B;AAC3BV,QAAAA,KAAK,CAACS,oBAAN,GAA6B,KAA7B;AACAT,QAAAA,KAAK,CAACU,kBAAN,GAA2B,IAA3B;;AACA,YAAII,eAAJ,EAAqB;AACjBN,UAAAA,KAAK,CAACM,eAAD,CAAL;AACH,SAFD,MAGK;AACD,kCAAaN,KAAb;AACH;AACJ;AACJ,KAZD,MAaK;AACDR,MAAAA,KAAK,CAACS,oBAAN,GAA6B,IAA7B;AACAT,MAAAA,KAAK,CAACG,UAAN,GAAmB,EAAnB;AACH;;AAED,QAAMb,IAAI,GAAGH,SAAS,CAACkB,SAAD,EAAYD,SAAZ,CAAtB;AACAJ,IAAAA,KAAK,CAACM,IAAN,GAAajC,MAAM,CAAC0C,MAAP,CAAc,EAAd,EAAkBV,SAAlB,EAA6BD,SAA7B,CAAb;;AACA,QAAI/B,MAAM,CAACC,IAAP,CAAYgB,IAAZ,EAAkBuB,MAAlB,KAA6B,CAAjC,EAAoC;AAChC,+CAAuBf,cAAvB,EAAuCR,IAAvC,EAA6CW,YAA7C,EAA2DC,QAA3D,EAAqEiB,aAArE;AACH;AACJ,G;;;gBApTOlC,U;sBACF5B,gB;mBAmBeoB,a;4BA4CjB2C,mC;kBAbIH,kB;eASK9B;;;;;;;;;;;AAyPN,SAASkC,gBAAT,CAA0BtB,OAA1B,EAAmCuB,YAAnC,EAAiDpB,QAAjD,EAA2D;AAC9D,MAAMJ,cAAc,GAAGpD,cAAc,CAAC;AAAE6E,IAAAA,GAAG,EAAE,CAAC,CAAR;AAAWC,IAAAA,IAAI,EAAE;AAAjB,GAAD,EAA0B,KAA1B,CAArC;AACA,MAAMtE,OAAO,GAAG,mBAAO,IAAP,CAAhB;AACA,MAAMuE,MAAM,GAAGpD,MAAM,CAACqD,MAAP,CAAc3B,OAAO,CAAC4B,QAAtB,CAAf;AACA,MAAMC,OAAO,GAAG,mBAAO,IAAP,CAAhB;AACA1B,EAAAA,QAAQ,GAAG,CAACA,QAAD,IAAazC,KAAK,CAACC,OAAN,CAAcwC,QAAd,CAAb,GAAuCA,QAAvC,GAAkD,CAACA,QAAD,CAA7D;AACA,MAAM2B,YAAY,GAAG3B,QAAQ,GAAG4B,iBAAiB,CAAC5B,QAAD,CAApB,GAAiC,IAA9D;AACA,MAAMvB,gBAAgB,GAAGjC,cAAc,CAAC,IAAD,CAAvC;AACA,MAAIyE,aAAJ;;AACA,MAAIY,OAAO,CAACC,GAAR,CAAYC,cAAhB,EAAgC;AAC5Bd,IAAAA,aAAa,GAAG,mBAAO,EAAP,CAAhB;AACH;;AAED,MAAI,CAACG,YAAL,EAAmB;AACfA,IAAAA,YAAY,8CAAOG,MAAP,IAAe1B,OAAO,CAACmC,aAAvB,EAAZ;AACH,GAFD,MAGK;AACDZ,IAAAA,YAAY,CAACa,IAAb,CAAkBpC,OAAO,CAACmC,aAA1B;AACH;;AACDL,EAAAA,YAAY,IAAIP,YAAY,CAACa,IAAb,CAAkBN,YAAlB,CAAhB;;AACA,MAAI3E,OAAO,CAACL,OAAR,KAAoB,IAAxB,EAA8B;AAC1B,QAAMuF,QAAO,GAAG,mCAAkBrC,OAAlB,CAAhB;;AACAL,IAAAA,sBAAsB,CAAC0C,QAAD,CAAtB;AACAlF,IAAAA,OAAO,CAACL,OAAR,GAAkB;AACduF,MAAAA,OAAO,EAAPA,QADc;AAEdC,MAAAA,WAAW,EAAE,sBAAW;AAAE/B,QAAAA,IAAI,EAAE8B;AAAR,OAAX;AAFC,KAAlB;AAIH;;AACD,yBAAiClF,OAAO,CAACL,OAAzC;AAAA,MAAQwF,WAAR,oBAAQA,WAAR;AAAA,MAAqBD,OAArB,oBAAqBA,OAArB;AACA,MAAMnC,YAAY,GAAGqC,0BAAiBC,MAAjB,GAA0BtE,SAA1B,GAAsC2D,OAA3D;AACA,wBAAU,YAAM;AACZ,QAAIY,GAAJ;;AACA,QAAIT,OAAO,CAACC,GAAR,CAAYC,cAAhB,EAAgC;AAC5BO,MAAAA,GAAG;AAAA,+BAAS;AAERtB,UAAAA,gBAAgB,CAACpB,cAAD,EAAiBC,OAAjB,EAA0BsC,WAA1B,EAAuCpC,YAAvC,EAAqDC,QAArD,EAA+DvB,gBAA/D,EAAiFwC,aAAjF,CAAhB;AACH,SAHE;;AAAA;AAAA,4BArWbD,gBAqWa;AAAA,0BArWIpB,cAqWJ;AAAA,mBArWoBC,OAqWpB;AAAA,uBArW6BsC,WAqW7B;AAAA,wBArW0CpC,YAqW1C;AAAA,oBArWwDC,QAqWxD;AAAA,4BArWkEvB,gBAqWlE;AAAA,yBArWoFwC;AAqWpF;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA,SAAH;AAIH,KALD,MAMK;AACDqB,MAAAA,GAAG;AAAA,+BAAS;AAER3C,UAAAA,YAAY,CAACC,cAAD,EAAiBC,OAAjB,EAA0BsC,WAA1B,EAAuCpC,YAAvC,EAAqDC,QAArD,EAA+DvB,gBAA/D,CAAZ;AACH,SAHE;;AAAA;AAAA,wBA3WbkB,YA2Wa;AAAA,0BA3WAC,cA2WA;AAAA,mBA3WgBC,OA2WhB;AAAA,uBA3WyBsC,WA2WzB;AAAA,wBA3WsCpC,YA2WtC;AAAA,oBA3WoDC,QA2WpD;AAAA,4BA3W8DvB;AA2W9D;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA,SAAH;AAIH;;AACD,QAAM8D,QAAQ,GAAG,uBAAYD,GAAZ,EAAiBf,MAAjB,EAAyB,EAAzB,CAAjB;AACA,WAAO,YAAM;AACT,4BAAWgB,QAAX;AACH,KAFD;AAGH,GAlBD,EAkBGnB,YAlBH;AAmBA,wBAAU,YAAM;AACZ3C,IAAAA,gBAAgB,CAACX,KAAjB,GAAyB,IAAzB;AACA,WAAO,YAAM;AACTd,MAAAA,OAAO,CAACL,OAAR,GAAkB,IAAlB;AACA+E,MAAAA,OAAO,CAAC/E,OAAR,GAAkB,IAAlB;AACA8B,MAAAA,gBAAgB,CAACX,KAAjB,GAAyB,KAAzB;AACH,KAJD;AAKH,GAPD,EAOG,EAPH;AASA,MAAI0E,QAAJ;;AACA,MAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACC,OAAD,EAAUrE,GAAV,EAAkB;AACpC,QAAMG,MAAM,GAAG,OAAOkE,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,CAAC5E,KAAR,KAAkBC,SAAhE;;AACA,QAAIS,MAAJ,EAAY;AACRgE,MAAAA,QAAQ,GAAGnE,GAAX;AACH;;AACD,WAAO,CAACG,MAAR;AACH,GAND;;AAOA,MAAMmE,OAAO,GAAGxE,MAAM,CAACC,IAAP,CAAY8D,OAAZ,EAAqBlD,IAArB,CAA0B,UAACX,GAAD,EAAS;AAC/C,QAAMqE,OAAO,GAAGR,OAAO,CAAC7D,GAAD,CAAvB;AACA,QAAIG,MAAM,GAAG,KAAb;;AAEA,QAAIjB,KAAK,CAACC,OAAN,CAAckF,OAAd,CAAJ,EAA4B;AACxB,2DAA+BA,OAA/B,wCAAwC;AAAA,YAA7BE,gBAA6B;;AAEpC,YAAI,OAAOA,gBAAP,KAA4B,QAAhC,EAA0C;AACtC;AACH;;AACD,YAAMC,WAAW,GAAG1E,MAAM,CAACqD,MAAP,CAAcoB,gBAAd,EAAgC,CAAhC,CAApB;AACApE,QAAAA,MAAM,GAAGiE,aAAa,CAACI,WAAD,EAAcxE,GAAd,CAAtB;;AACA,YAAI,CAACG,MAAL,EAAa;AACT;AACH;AACJ;AACJ,KAZD,MAaK;AACDA,MAAAA,MAAM,GAAGiE,aAAa,CAACC,OAAD,EAAUrE,GAAV,CAAtB;AACH;;AACD,WAAO,CAACG,MAAR;AACH,GArBe,CAAhB;;AAsBA,MAAImE,OAAO,IAAIH,QAAQ,KAAKzE,SAA5B,EAAuC;AACnC,UAAM,IAAI2B,KAAJ,+BAAuC8C,QAAvC,0CAAN;AACH;;AACD,MAAIX,OAAO,CAACC,GAAR,CAAYC,cAAhB,EAAgC;AAC5B,WAAO;AAAEnC,MAAAA,cAAc,EAAdA,cAAF;AAAkBsC,MAAAA,OAAO,EAAPA,OAAlB;AAA2BR,MAAAA,OAAO,EAAPA,OAA3B;AAAoCT,MAAAA,aAAa,EAAbA;AAApC,KAAP;AACH,GAFD,MAGK;AACD,WAAO;AAAErB,MAAAA,cAAc,EAAdA,cAAF;AAAkBsC,MAAAA,OAAO,EAAPA,OAAlB;AAA2BR,MAAAA,OAAO,EAAPA;AAA3B,KAAP;AACH;AACJ;;AAGM,IAAMoB,gBAAgB,GAAG3B,gBAAzB;;;AACA,SAAS4B,eAAT,CAAyBC,SAAzB,EAAoC5B,YAApC,EAAkD;AACrD,MAAMpE,OAAO,GAAG,mBAAO,IAAP,CAAhB;AACA,MAAMuE,MAAM,GAAGpD,MAAM,CAACqD,MAAP,CAAcwB,SAAS,CAACvB,QAAxB,CAAf;;AAEA,MAAIL,YAAY,KAAKrD,SAArB,EAAgC;AAC5BqD,IAAAA,YAAY,8CAAOG,MAAP,IAAeyB,SAAS,CAAChB,aAAzB,EAAZ;AACH,GAFD,MAGK;AACDZ,IAAAA,YAAY,CAACa,IAAb,CAAkBe,SAAS,CAAChB,aAA5B;AACH;;AACD,MAAIhF,OAAO,CAACL,OAAR,KAAoB,IAAxB,EAA8B;AAC1BK,IAAAA,OAAO,CAACL,OAAR,GAAkB,uBAAY,mCAAkBqG,SAAlB,CAAZ,CAAlB;AACH;;AACD,MAAMC,WAAW,GAAGjG,OAAO,CAACL,OAA5B;AACA,wBAAU,YAAM;AACZ,QAAM2F,GAAG;AAAA,6BAAS;AAEdW,QAAAA,WAAW,CAACnF,KAAZ,GAAoBkF,SAAS,EAA7B;AACH,OAHQ;;AAAA;AAAA,qBAxbfC,WAwbe;AAAA,mBAxbKD;AAwbL;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA,OAAT;;AAIA,QAAMT,QAAQ,GAAG,uBAAYD,GAAZ,EAAiBf,MAAjB,EAAyB,CAAC0B,WAAD,CAAzB,CAAjB;AACA,WAAO,YAAM;AACT,4BAAWV,QAAX;AACH,KAFD;AAGH,GATD,EASGnB,YATH;AAUA,wBAAU,YAAM;AACZ,WAAO,YAAM;AACTpE,MAAAA,OAAO,CAACL,OAAR,GAAkB,IAAlB;AACH,KAFD;AAGH,GAJD,EAIG,EAJH;AAKA,SAAOsG,WAAP;AACH;;AAED,SAASrB,iBAAT,CAA2BsB,QAA3B,EAAqC;AACjC,SAAO/E,MAAM,CAACC,IAAP,CAAY8E,QAAZ,EAAsBC,MAAtB,CAA6B,UAACC,aAAD,EAAgB/E,GAAhB;AAAA,WAAwB+E,aAAa,KAAK,IAAlB,GACtDF,QAAQ,CAAC7E,GAAD,CAAR,CAAc2D,aADwC,GAEtDoB,aAAa,CAACC,QAAd,KAA2BH,QAAQ,CAAC7E,GAAD,CAAR,CAAc2D,aAAd,CAA4BqB,QAA5B,EAFG;AAAA,GAA7B,EAEkE,IAFlE,CAAP;AAGH;;AAED,SAASC,iBAAT,CAA2BlC,YAA3B,EAAyC8B,QAAzC,EAAmD;AAC/C,MAAI,CAAC9B,YAAL,EAAmB;AACfA,IAAAA,YAAY,GAAGjD,MAAM,CAACC,IAAP,CAAY8E,QAAZ,EAAsBK,GAAtB,CAA0B,UAACC,UAAD,EAAgB;AACrD,UAAM3G,OAAO,GAAGqG,QAAQ,CAACM,UAAD,CAAxB;AACA,aAAO;AACHC,QAAAA,WAAW,EAAE5G,OAAO,CAACmF,aADlB;AAEH0B,QAAAA,OAAO,EAAE7G,OAAO,CAAC4E;AAFd,OAAP;AAIH,KANc,CAAf;AAOH,GARD,MASK;AACDL,IAAAA,YAAY,CAACa,IAAb,CAAkBL,iBAAiB,CAACsB,QAAD,CAAnC;AACH;;AACD,SAAO9B,YAAP;AACH;;AAED,SAASuC,oBAAT,CAA8BC,QAA9B,EAAwCC,QAAxC,EAAkD;AAC9C,WAASC,EAAT,CAAYC,CAAZ,EAAeC,CAAf,EAAkB;AAEd,WAAQD,CAAC,KAAKC,CAAN,KAAYD,CAAC,KAAK,CAAN,IAAW,IAAIA,CAAJ,KAAU,IAAIC,CAArC,CAAD,IAA8CD,CAAC,KAAKA,CAAN,IAAWC,CAAC,KAAKA,CAAtE;AAEH;;AACD,MAAMC,QAAQ,GAAG,OAAO9F,MAAM,CAAC2F,EAAd,KAAqB,UAArB,GAAkC3F,MAAM,CAAC2F,EAAzC,GAA8CA,EAA/D;;AACA,WAASI,kBAAT,CAA4BN,QAA5B,EAAsCC,QAAtC,EAAgD;AAC5C,QAAI,CAACD,QAAD,IAAa,CAACC,QAAd,IAA0BA,QAAQ,CAAClD,MAAT,KAAoBiD,QAAQ,CAACjD,MAA3D,EAAmE;AAC/D,aAAO,KAAP;AACH;;AACD,SAAK,IAAIwD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,QAAQ,CAAClD,MAA7B,EAAqC,EAAEwD,CAAvC,EAA0C;AACtC,UAAI,CAACF,QAAQ,CAACL,QAAQ,CAACO,CAAD,CAAT,EAAcN,QAAQ,CAACM,CAAD,CAAtB,CAAb,EAAyC;AACrC,eAAO,KAAP;AACH;AACJ;;AACD,WAAO,IAAP;AACH;;AACD,SAAOD,kBAAkB,CAACN,QAAD,EAAWC,QAAX,CAAzB;AACH;;AACM,SAASO,yBAAT,CAAmClB,QAAnC,EAA6C9B,YAA7C,EAA2D;AAC9D,MAAMpE,OAAO,GAAG,mBAAO,IAAP,CAAhB;;AACA,MAAIA,OAAO,CAACL,OAAR,KAAoB,IAAxB,EAA8B;AAC1BK,IAAAA,OAAO,CAACL,OAAR,GAAkB;AACd0H,MAAAA,OAAO,EAAE,sBAAW,EAAX,CADK;AAEdC,MAAAA,iBAAiB,EAAE;AAFL,KAAlB;AAIH;;AACD,wBAAU,YAAM;AACZ,WAAO,YAAM;AACTtH,MAAAA,OAAO,CAACL,OAAR,GAAkB,IAAlB;AACH,KAFD;AAGH,GAJD,EAIG,EAJH;AAKA,0BAAuCK,OAAO,CAACL,OAA/C;AAAA,MAAQ0H,OAAR,qBAAQA,OAAR;AAAA,MAAiBC,iBAAjB,qBAAiBA,iBAAjB;AACAlD,EAAAA,YAAY,GAAGkC,iBAAiB,CAAClC,YAAD,EAAe8B,QAAf,CAAhC;AACA,MAAMqB,kBAAkB,GAAG,CAACZ,oBAAoB,CAACvC,YAAD,EAAekD,iBAAf,CAAhD;AACAtH,EAAAA,OAAO,CAACL,OAAR,CAAgB2H,iBAAhB,GAAoClD,YAApC;;AACA,MAAMvE,OAAO;AAAA,yBAAI2H,KAAJ,EAAc;AAEvBA,MAAAA,KAAK,GAAGC,sBAASC,EAAT,KAAgB,KAAhB,GAAwBF,KAAK,CAACG,WAA9B,GAA4CH,KAApD;AACA,UAAMI,MAAM,GAAG,CAAf;AACA,UAAMC,KAAK,GAAG,CAAd;AACA,UAAMC,SAAS,GAAG,CAAlB;AACA,UAAMC,MAAM,GAAG,CAAf;AACA,UAAMC,GAAG,GAAG,CAAZ;;AACA,UAAIR,KAAK,CAAC1E,KAAN,KAAgB+E,KAAhB,IAAyB3B,QAAQ,CAAChF,OAAtC,EAA+C;AAC3CgF,QAAAA,QAAQ,CAAChF,OAAT,CAAiBsG,KAAjB,EAAwBH,OAAxB;AACH;;AACD,UAAIG,KAAK,CAAC1E,KAAN,KAAgBiF,MAAhB,IAA0B7B,QAAQ,CAAC+B,QAAvC,EAAiD;AAC7C/B,QAAAA,QAAQ,CAAC+B,QAAT,CAAkBT,KAAlB,EAAyBH,OAAzB;AACH;;AACD,UAAIG,KAAK,CAACU,QAAN,KAAmBH,MAAnB,IAA6BP,KAAK,CAAC1E,KAAN,KAAgBkF,GAA7C,IAAoD9B,QAAQ,CAACiC,KAAjE,EAAwE;AACpEjC,QAAAA,QAAQ,CAACiC,KAAT,CAAeX,KAAf,EAAsBH,OAAtB;AACH;;AACD,UAAIG,KAAK,CAACU,QAAN,KAAmBL,KAAnB,IAA4BL,KAAK,CAAC1E,KAAN,KAAgB8E,MAA5C,IAAsD1B,QAAQ,CAACkC,MAAnE,EAA2E;AACvElC,QAAAA,QAAQ,CAACkC,MAAT,CAAgBZ,KAAhB,EAAuBH,OAAvB;AACH;;AACD,UAAIG,KAAK,CAACU,QAAN,KAAmBH,MAAnB,IACAP,KAAK,CAAC1E,KAAN,KAAgBgF,SADhB,IAEA5B,QAAQ,CAACmC,QAFb,EAEuB;AACnBnC,QAAAA,QAAQ,CAACmC,QAAT,CAAkBb,KAAlB,EAAyBH,OAAzB;AACH;;AACD,UAAI,CAACG,KAAK,CAACU,QAAN,KAAmBL,KAAnB,IAA4BL,KAAK,CAACU,QAAN,KAAmBH,MAAhD,KACAP,KAAK,CAAC1E,KAAN,KAAgB+E,KADhB,IAEAL,KAAK,CAAC1E,KAAN,KAAgBiF,MAFhB,IAGA7B,QAAQ,CAACoC,QAHb,EAGuB;AACnBpC,QAAAA,QAAQ,CAACoC,QAAT,CAAkBd,KAAlB,EAAyBH,OAAzB,EAAkCG,KAAK,CAAC1E,KAAN,KAAgBgF,SAAhB,IAA6BN,KAAK,CAAC1E,KAAN,KAAgB8E,MAA/E;AACH;AACJ,KA/BY;;AAAA;AAAA;AAAA,YApgBPH,sBAASC;AAogBF;AAAA;AAAA,iBA5fbxB,QAAQ,CAAChF,OA4fI;AAAA,kBAxfbgF,QAAQ,CAAC+B,QAwfI;AAAA,eApfb/B,QAAQ,CAACiC,KAofI;AAAA,gBAhfbjC,QAAQ,CAACkC,MAgfI;AAAA,kBA5eblC,QAAQ,CAACmC,QA4eI;AAAA,kBAxebnC,QAAQ,CAACoC;AAweI;AAAA,eAxeYjB;AAweZ;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA,KAAb;;AAgCA,MAAII,sBAASC,EAAT,KAAgB,KAApB,EAA2B;AACvB,WAAO7H,OAAP;AACH;;AACD,SAAOD,QAAQ,CAACC,OAAD,EAAU,CAAC,6BAAD,EAAgC,uBAAhC,CAAV,EAAoE0H,kBAApE,CAAf;AACH;;AACM,SAASgB,wBAAT,CAAkCrC,QAAlC,EAA4C9B,YAA5C,EAA0D;AAC7D,MAAMpE,OAAO,GAAG,mBAAO,IAAP,CAAhB;;AACA,MAAIA,OAAO,CAACL,OAAR,KAAoB,IAAxB,EAA8B;AAC1BK,IAAAA,OAAO,CAACL,OAAR,GAAkB;AACd0H,MAAAA,OAAO,EAAE,sBAAW,EAAX,CADK;AAEdC,MAAAA,iBAAiB,EAAE;AAFL,KAAlB;AAIH;;AACD,wBAAU,YAAM;AACZ,WAAO,YAAM;AACTtH,MAAAA,OAAO,CAACL,OAAR,GAAkB,IAAlB;AACH,KAFD;AAGH,GAJD,EAIG,EAJH;AAKA,0BAAuCK,OAAO,CAACL,OAA/C;AAAA,MAAQ0H,OAAR,qBAAQA,OAAR;AAAA,MAAiBC,iBAAjB,qBAAiBA,iBAAjB;AACAlD,EAAAA,YAAY,GAAGkC,iBAAiB,CAAClC,YAAD,EAAe8B,QAAf,CAAhC;AACA,MAAMqB,kBAAkB,GAAG,CAACZ,oBAAoB,CAACvC,YAAD,EAAekD,iBAAf,CAAhD;AACAtH,EAAAA,OAAO,CAACL,OAAR,CAAgB2H,iBAAhB,GAAoClD,YAApC;AAEA,MAAMoE,kBAAkB,GAAG,CAAC,UAAD,CAA3B;;AACA,MAAItC,QAAQ,CAACuC,WAAT,KAAyB1H,SAA7B,EAAwC;AACpCyH,IAAAA,kBAAkB,CAACvD,IAAnB,CAAwB,mBAAxB;AACH;;AACD,MAAIiB,QAAQ,CAACwC,SAAT,KAAuB3H,SAA3B,EAAsC;AAClCyH,IAAAA,kBAAkB,CAACvD,IAAnB,CAAwB,iBAAxB;AACH;;AACD,MAAIiB,QAAQ,CAACyC,eAAT,KAA6B5H,SAAjC,EAA4C;AACxCyH,IAAAA,kBAAkB,CAACvD,IAAnB,CAAwB,uBAAxB;AACH;;AACD,MAAIiB,QAAQ,CAAC0C,aAAT,KAA2B7H,SAA/B,EAA0C;AACtCyH,IAAAA,kBAAkB,CAACvD,IAAnB,CAAwB,qBAAxB;AACH;;AACD,SAAOrF,QAAQ;AAAA,yBAAE4H,KAAF,EAAY;AAEvB,UAAQqB,QAAR,GAA8E3C,QAA9E,CAAQ2C,QAAR;AAAA,UAAkBJ,WAAlB,GAA8EvC,QAA9E,CAAkBuC,WAAlB;AAAA,UAA+BC,SAA/B,GAA8ExC,QAA9E,CAA+BwC,SAA/B;AAAA,UAA0CC,eAA1C,GAA8EzC,QAA9E,CAA0CyC,eAA1C;AAAA,UAA2DC,aAA3D,GAA8E1C,QAA9E,CAA2D0C,aAA3D;;AACA,UAAIpB,KAAK,CAACsB,SAAN,CAAgBC,QAAhB,CAAyB,UAAzB,CAAJ,EAA0C;AACtC,YAAIF,QAAJ,EAAc;AACVA,UAAAA,QAAQ,CAACrB,KAAD,EAAQH,OAAR,CAAR;AACH,SAFD,MAGK,IAAI,OAAOnB,QAAP,KAAoB,UAAxB,EAAoC;AACrCA,UAAAA,QAAQ,CAACsB,KAAD,EAAQH,OAAR,CAAR;AACH;AACJ,OAPD,MAQK,IAAIoB,WAAW,IAAIjB,KAAK,CAACsB,SAAN,CAAgBC,QAAhB,CAAyB,mBAAzB,CAAnB,EAAkE;AACnEN,QAAAA,WAAW,CAACjB,KAAD,EAAQH,OAAR,CAAX;AACH,OAFI,MAGA,IAAIqB,SAAS,IAAIlB,KAAK,CAACsB,SAAN,CAAgBC,QAAhB,CAAyB,iBAAzB,CAAjB,EAA8D;AAC/DL,QAAAA,SAAS,CAAClB,KAAD,EAAQH,OAAR,CAAT;AACH,OAFI,MAGA,IAAIsB,eAAe,IACpBnB,KAAK,CAACsB,SAAN,CAAgBC,QAAhB,CAAyB,uBAAzB,CADC,EACkD;AACnDJ,QAAAA,eAAe,CAACnB,KAAD,EAAQH,OAAR,CAAf;AACH,OAHI,MAIA,IAAIuB,aAAa,IAClBpB,KAAK,CAACsB,SAAN,CAAgBC,QAAhB,CAAyB,qBAAzB,CADC,EACgD;AACjDH,QAAAA,aAAa,CAACpB,KAAD,EAAQH,OAAR,CAAb;AACH;AACJ,KAzBc;;AAAA;AAAA,gBA9jBbnB,QA8jBa;AAAA,eArjBMmB;AAqjBN;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA,OAyBZmB,kBAzBY,EAyBQjB,kBAzBR,CAAf;AA0BH;;AACM,SAASyB,cAAT,GAA0B;AAC7B,MAAM3E,GAAG,GAAG7E,cAAc,CAAC,CAAC,CAAF,CAA1B;AACA,MAAME,GAAG,GAAG,mBAAO,IAAP,CAAZ;;AACA,MAAI,CAACA,GAAG,CAACC,OAAT,EAAkB;AACd,QAAM2F,GAAG;AAAA,2BAAa2D,SAAb,EAAwB;AAG7B,YAAIA,SAAJ,EAAe;AACX5E,UAAAA,GAAG,CAACvD,KAAJ,GAAY,2BAAOmI,SAAP,CAAZ;AACA3D,UAAAA,GAAG,CAAC3F,OAAJ,GAAcsJ,SAAd;AACH;;AACD,eAAO5E,GAAG,CAACvD,KAAX;AACH,OARQ;;AAAA;AAAA,aAlmBRuD,GAkmBQ;AAAA,gBAtmBD6E,qBAsmBC;AAAA,aArmBb5D;AAqmBa;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA,OAAT;;AASAnE,IAAAA,MAAM,CAACgI,cAAP,CAAsB7D,GAAtB,EAA2B,SAA3B,EAAsC;AAClCxE,MAAAA,KAAK,EAAE,IAD2B;AAElCsI,MAAAA,QAAQ,EAAE,IAFwB;AAGlCC,MAAAA,UAAU,EAAE;AAHsB,KAAtC;AAKA3J,IAAAA,GAAG,CAACC,OAAJ,GAAc2F,GAAd;AACH;;AACD,SAAO5F,GAAG,CAACC,OAAX;AACH;;AAOM,SAAS2J,mBAAT,CAA6BC,OAA7B,EAAsCC,KAAtC,EAA6CpF,YAA7C,EAA2D;AAC9D,MAAMqF,QAAQ,GAAGjK,cAAc,CAAC,IAAD,CAA/B;;AACA,MAAI4E,YAAY,KAAKrD,SAArB,EAAgC;AAC5BqD,IAAAA,YAAY,GAAG,CACXjD,MAAM,CAACqD,MAAP,CAAc+E,OAAO,CAAC9E,QAAtB,CADW,EAEXtD,MAAM,CAACqD,MAAP,CAAcgF,KAAK,CAAC/E,QAApB,CAFW,EAGX8E,OAAO,CAACvE,aAHG,EAIXwE,KAAK,CAACxE,aAJK,CAAf;AAMH,GAPD,MAQK;AACDZ,IAAAA,YAAY,CAACa,IAAb,CAAkBsE,OAAO,CAACvE,aAA1B,EAAyCwE,KAAK,CAACxE,aAA/C;AACH;;AACD,wBAAU,YAAM;AACZ,QAAMM,GAAG;AAAA,6BAAS;AAEd,YAAMoE,KAAK,GAAGH,OAAO,EAArB;AACAC,QAAAA,KAAK,CAACE,KAAD,EAAQD,QAAQ,CAAC3I,KAAjB,CAAL;AACA2I,QAAAA,QAAQ,CAAC3I,KAAT,GAAiB4I,KAAjB;AACH,OALQ;;AAAA;AAAA,iBA7oBHH,OA6oBG;AAAA,eA5oBfC,KA4oBe;AAAA,kBA3oBfC;AA2oBe;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA,OAAT;;AAMA,QAAMlE,QAAQ,GAAG,uBAAYD,GAAZ,EAAiBnE,MAAM,CAACqD,MAAP,CAAc+E,OAAO,CAAC9E,QAAtB,CAAjB,EAAkD,EAAlD,CAAjB;AACA,WAAO,YAAM;AACT,4BAAWc,QAAX;AACH,KAFD;AAGH,GAXD,EAWGnB,YAXH;AAYH;;AACM,SAASuF,kBAAT,CAA4BrE,GAA5B,EAAiCsE,IAAjC,EAAuC;AAC1C,SAAO,wBAAYtE,GAAZ,EAAiBsE,IAAjB,CAAP;AACH;;AACM,SAASC,aAAT,CAAuBvE,GAAvB,EAA4B;AAC/B,SAAOA,GAAP;AACH",
    "sourcesContent": [
      "/* global _frameTimestamp */\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\nimport { useEffect, useRef, useCallback } from 'react';\nimport WorkletEventHandler from './WorkletEventHandler';\nimport { startMapper, stopMapper, makeMutable, makeRemote, requestFrame, getTimestamp, } from './core';\nimport updateProps, { updatePropsJestWrapper } from './UpdateProps';\nimport { initialUpdaterRun, cancelAnimation } from './animations';\nimport { getTag } from './NativeMethods';\nimport NativeReanimated from './NativeReanimated';\nimport { Platform } from 'react-native';\nexport function useSharedValue(init) {\n    const ref = useRef(null);\n    if (ref.current === null) {\n        ref.current = makeMutable(init);\n    }\n    useEffect(() => {\n        return () => {\n            cancelAnimation(ref.current);\n        };\n    }, []);\n    return ref.current;\n}\nexport function useEvent(handler, eventNames = [], rebuild = false) {\n    const initRef = useRef(null);\n    if (initRef.current === null) {\n        initRef.current = new WorkletEventHandler(handler, eventNames);\n    }\n    else if (rebuild) {\n        initRef.current.updateWorklet(handler);\n    }\n    useEffect(() => {\n        return () => {\n            initRef.current = null;\n        };\n    }, []);\n    return initRef;\n}\nfunction prepareAnimation(animatedProp, lastAnimation, lastValue) {\n    'worklet';\n    function prepareAnimation(animatedProp, lastAnimation, lastValue) {\n        if (Array.isArray(animatedProp)) {\n            animatedProp.forEach((prop, index) => prepareAnimation(prop, lastAnimation && lastAnimation[index], lastValue && lastValue[index]));\n            return animatedProp;\n        }\n        if (typeof animatedProp === 'object' && animatedProp.onFrame) {\n            const animation = animatedProp;\n            let value = animation.current;\n            if (lastValue !== undefined) {\n                if (typeof lastValue === 'object') {\n                    if (lastValue.value !== undefined) {\n                        // previously it was a shared value\n                        value = lastValue.value;\n                    }\n                    else if (lastValue.onFrame !== undefined) {\n                        if ((lastAnimation === null || lastAnimation === void 0 ? void 0 : lastAnimation.current) !== undefined) {\n                            // it was an animation before, copy its state\n                            value = lastAnimation.current;\n                        }\n                        else if ((lastValue === null || lastValue === void 0 ? void 0 : lastValue.current) !== undefined) {\n                            // it was initialized\n                            value = lastValue.current;\n                        }\n                    }\n                }\n                else {\n                    // previously it was a plain value, just set it as starting point\n                    value = lastValue;\n                }\n            }\n            animation.callStart = (timestamp) => {\n                animation.onStart(animation, value, timestamp, lastAnimation);\n            };\n            animation.callStart(getTimestamp());\n            animation.callStart = null;\n        }\n        else if (typeof animatedProp === 'object') {\n            // it is an object\n            Object.keys(animatedProp).forEach((key) => prepareAnimation(animatedProp[key], lastAnimation && lastAnimation[key], lastValue && lastValue[key]));\n        }\n    }\n    return prepareAnimation(animatedProp, lastAnimation, lastValue);\n}\nfunction runAnimations(animation, timestamp, key, result, animationsActive) {\n    'worklet';\n    function runAnimations(animation, timestamp, key, result, animationsActive) {\n        if (!animationsActive.value) {\n            return true;\n        }\n        if (Array.isArray(animation)) {\n            result[key] = [];\n            let allFinished = true;\n            animation.forEach((entry, index) => {\n                if (!runAnimations(entry, timestamp, index, result[key], animationsActive)) {\n                    allFinished = false;\n                }\n            });\n            return allFinished;\n        }\n        else if (typeof animation === 'object' && animation.onFrame) {\n            let finished = true;\n            if (!animation.finished) {\n                if (animation.callStart) {\n                    animation.callStart(timestamp);\n                    animation.callStart = null;\n                }\n                finished = animation.onFrame(animation, timestamp);\n                animation.timestamp = timestamp;\n                if (finished) {\n                    animation.finished = true;\n                    animation.callback && animation.callback(true /* finished */);\n                }\n            }\n            result[key] = animation.current;\n            return finished;\n        }\n        else if (typeof animation === 'object') {\n            result[key] = {};\n            let allFinished = true;\n            Object.keys(animation).forEach((k) => {\n                if (!runAnimations(animation[k], timestamp, k, result[key], animationsActive)) {\n                    allFinished = false;\n                }\n            });\n            return allFinished;\n        }\n        else {\n            result[key] = animation;\n            return true;\n        }\n    }\n    return runAnimations(animation, timestamp, key, result, animationsActive);\n}\n// TODO: recirsive worklets aren't supported yet\nfunction isAnimated(prop) {\n    'worklet';\n    function isAnimated(prop) {\n        if (Array.isArray(prop)) {\n            return prop.some(isAnimated);\n        }\n        if (typeof prop === 'object') {\n            if (prop.onFrame) {\n                return true;\n            }\n            return Object.keys(prop).some((key) => isAnimated(prop[key]));\n        }\n        return false;\n    }\n    return isAnimated(prop);\n}\nfunction styleDiff(oldStyle, newStyle) {\n    'worklet';\n    const diff = {};\n    Object.keys(oldStyle).forEach((key) => {\n        if (newStyle[key] === undefined) {\n            diff[key] = null;\n        }\n    });\n    Object.keys(newStyle).forEach((key) => {\n        const value = newStyle[key];\n        const oldValue = oldStyle[key];\n        if (isAnimated(value)) {\n            // do nothing\n            return;\n        }\n        if (oldValue !== value &&\n            JSON.stringify(oldValue) !== JSON.stringify(value)) {\n            // I'd use deep equal here but that'd take additional work and this was easier\n            diff[key] = value;\n        }\n    });\n    return diff;\n}\nconst validateAnimatedStyles = (styles) => {\n    'worklet';\n    if (typeof styles !== 'object') {\n        throw new Error(`useAnimatedStyle has to return an object, found ${typeof styles} instead`);\n    }\n    else if (Array.isArray(styles)) {\n        throw new Error('useAnimatedStyle has to return an object and cannot return static styles combined with dynamic ones. Please do merging where a component receives props.');\n    }\n};\nfunction styleUpdater(viewDescriptor, updater, state, maybeViewRef, adapters, animationsActive) {\n    'worklet';\n    const animations = state.animations || {};\n    const newValues = updater() || {};\n    const oldValues = state.last;\n    // extract animated props\n    let hasAnimations = false;\n    Object.keys(animations).forEach((key) => {\n        const value = newValues[key];\n        if (!isAnimated(value)) {\n            delete animations[key];\n        }\n    });\n    Object.keys(newValues).forEach((key) => {\n        const value = newValues[key];\n        if (isAnimated(value)) {\n            prepareAnimation(value, animations[key], oldValues[key]);\n            animations[key] = value;\n            hasAnimations = true;\n        }\n    });\n    function frame(timestamp) {\n        const { animations, last, isAnimationCancelled } = state;\n        if (isAnimationCancelled) {\n            state.isAnimationRunning = false;\n            return;\n        }\n        const updates = {};\n        let allFinished = true;\n        Object.keys(animations).forEach((propName) => {\n            const finished = runAnimations(animations[propName], timestamp, propName, updates, animationsActive);\n            if (finished) {\n                last[propName] = updates[propName];\n                delete animations[propName];\n            }\n            else {\n                allFinished = false;\n            }\n        });\n        if (Object.keys(updates).length) {\n            updateProps(viewDescriptor, updates, maybeViewRef, adapters);\n        }\n        if (!allFinished) {\n            requestFrame(frame);\n        }\n        else {\n            state.isAnimationRunning = false;\n        }\n    }\n    if (hasAnimations) {\n        state.animations = animations;\n        if (!state.isAnimationRunning) {\n            state.isAnimationCancelled = false;\n            state.isAnimationRunning = true;\n            if (_frameTimestamp) {\n                frame(_frameTimestamp);\n            }\n            else {\n                requestFrame(frame);\n            }\n        }\n    }\n    else {\n        state.isAnimationCancelled = true;\n        state.animations = {};\n    }\n    // calculate diff\n    const diff = styleDiff(oldValues, newValues);\n    state.last = Object.assign({}, oldValues, newValues);\n    if (Object.keys(diff).length !== 0) {\n        updateProps(viewDescriptor, diff, maybeViewRef, adapters);\n    }\n}\nfunction jestStyleUpdater(viewDescriptor, updater, state, maybeViewRef, adapters, animationsActive, animatedStyle) {\n    'worklet';\n    const animations = state.animations || {};\n    const newValues = updater() || {};\n    const oldValues = state.last;\n    // extract animated props\n    let hasAnimations = false;\n    Object.keys(animations).forEach((key) => {\n        const value = newValues[key];\n        if (!isAnimated(value)) {\n            delete animations[key];\n        }\n    });\n    Object.keys(newValues).forEach((key) => {\n        const value = newValues[key];\n        if (isAnimated(value)) {\n            prepareAnimation(value, animations[key], oldValues[key]);\n            animations[key] = value;\n            hasAnimations = true;\n        }\n    });\n    function frame(timestamp) {\n        const { animations, last, isAnimationCancelled } = state;\n        if (isAnimationCancelled) {\n            state.isAnimationRunning = false;\n            return;\n        }\n        const updates = {};\n        let allFinished = true;\n        Object.keys(animations).forEach((propName) => {\n            const finished = runAnimations(animations[propName], timestamp, propName, updates, animationsActive);\n            if (finished) {\n                last[propName] = updates[propName];\n                delete animations[propName];\n            }\n            else {\n                allFinished = false;\n            }\n        });\n        if (Object.keys(updates).length) {\n            updatePropsJestWrapper(viewDescriptor, updates, maybeViewRef, adapters, animatedStyle);\n        }\n        if (!allFinished) {\n            requestFrame(frame);\n        }\n        else {\n            state.isAnimationRunning = false;\n        }\n    }\n    if (hasAnimations) {\n        state.animations = animations;\n        if (!state.isAnimationRunning) {\n            state.isAnimationCancelled = false;\n            state.isAnimationRunning = true;\n            if (_frameTimestamp) {\n                frame(_frameTimestamp);\n            }\n            else {\n                requestFrame(frame);\n            }\n        }\n    }\n    else {\n        state.isAnimationCancelled = true;\n        state.animations = {};\n    }\n    // calculate diff\n    const diff = styleDiff(oldValues, newValues);\n    state.last = Object.assign({}, oldValues, newValues);\n    if (Object.keys(diff).length !== 0) {\n        updatePropsJestWrapper(viewDescriptor, diff, maybeViewRef, adapters, animatedStyle);\n    }\n}\nexport function useAnimatedStyle(updater, dependencies, adapters) {\n    const viewDescriptor = useSharedValue({ tag: -1, name: null }, false);\n    const initRef = useRef(null);\n    const inputs = Object.values(updater._closure);\n    const viewRef = useRef(null);\n    adapters = !adapters || Array.isArray(adapters) ? adapters : [adapters];\n    const adaptersHash = adapters ? buildWorkletsHash(adapters) : null;\n    const animationsActive = useSharedValue(true);\n    let animatedStyle;\n    if (process.env.JEST_WORKER_ID) {\n        animatedStyle = useRef({});\n    }\n    // build dependencies\n    if (!dependencies) {\n        dependencies = [...inputs, updater.__workletHash];\n    }\n    else {\n        dependencies.push(updater.__workletHash);\n    }\n    adaptersHash && dependencies.push(adaptersHash);\n    if (initRef.current === null) {\n        const initial = initialUpdaterRun(updater);\n        validateAnimatedStyles(initial);\n        initRef.current = {\n            initial,\n            remoteState: makeRemote({ last: initial }),\n        };\n    }\n    const { remoteState, initial } = initRef.current;\n    const maybeViewRef = NativeReanimated.native ? undefined : viewRef;\n    useEffect(() => {\n        let fun;\n        if (process.env.JEST_WORKER_ID) {\n            fun = () => {\n                'worklet';\n                jestStyleUpdater(viewDescriptor, updater, remoteState, maybeViewRef, adapters, animationsActive, animatedStyle);\n            };\n        }\n        else {\n            fun = () => {\n                'worklet';\n                styleUpdater(viewDescriptor, updater, remoteState, maybeViewRef, adapters, animationsActive);\n            };\n        }\n        const mapperId = startMapper(fun, inputs, []);\n        return () => {\n            stopMapper(mapperId);\n        };\n    }, dependencies);\n    useEffect(() => {\n        animationsActive.value = true;\n        return () => {\n            initRef.current = null;\n            viewRef.current = null;\n            animationsActive.value = false;\n        };\n    }, []);\n    // check for invalid usage of shared values in returned object\n    let wrongKey;\n    const isObjectValid = (element, key) => {\n        const result = typeof element === 'object' && element.value !== undefined;\n        if (result) {\n            wrongKey = key;\n        }\n        return !result;\n    };\n    const isError = Object.keys(initial).some((key) => {\n        const element = initial[key];\n        let result = false;\n        // a case for transform that has a format of an array of objects\n        if (Array.isArray(element)) {\n            for (const elementArrayItem of element) {\n                // this means unhandled format and it doesn't match the transform format\n                if (typeof elementArrayItem !== 'object') {\n                    break;\n                }\n                const objectValue = Object.values(elementArrayItem)[0];\n                result = isObjectValid(objectValue, key);\n                if (!result) {\n                    break;\n                }\n            }\n        }\n        else {\n            result = isObjectValid(element, key);\n        }\n        return !result;\n    });\n    if (isError && wrongKey !== undefined) {\n        throw new Error(`invalid value passed to \\`${wrongKey}\\`, maybe you forgot to use \\`.value\\`?`);\n    }\n    if (process.env.JEST_WORKER_ID) {\n        return { viewDescriptor, initial, viewRef, animatedStyle };\n    }\n    else {\n        return { viewDescriptor, initial, viewRef };\n    }\n}\n// TODO: we should make sure that when useAP is used we are not assigning styles\n// when you need styles to animated you should always use useAS\nexport const useAnimatedProps = useAnimatedStyle;\nexport function useDerivedValue(processor, dependencies) {\n    const initRef = useRef(null);\n    const inputs = Object.values(processor._closure);\n    // build dependencies\n    if (dependencies === undefined) {\n        dependencies = [...inputs, processor.__workletHash];\n    }\n    else {\n        dependencies.push(processor.__workletHash);\n    }\n    if (initRef.current === null) {\n        initRef.current = makeMutable(initialUpdaterRun(processor));\n    }\n    const sharedValue = initRef.current;\n    useEffect(() => {\n        const fun = () => {\n            'worklet';\n            sharedValue.value = processor();\n        };\n        const mapperId = startMapper(fun, inputs, [sharedValue]);\n        return () => {\n            stopMapper(mapperId);\n        };\n    }, dependencies);\n    useEffect(() => {\n        return () => {\n            initRef.current = null;\n        };\n    }, []);\n    return sharedValue;\n}\n// builds one big hash from multiple worklets' hashes\nfunction buildWorkletsHash(handlers) {\n    return Object.keys(handlers).reduce((previousValue, key) => previousValue === null\n        ? handlers[key].__workletHash\n        : previousValue.toString() + handlers[key].__workletHash.toString(), null);\n}\n// builds dependencies array for gesture handlers\nfunction buildDependencies(dependencies, handlers) {\n    if (!dependencies) {\n        dependencies = Object.keys(handlers).map((handlerKey) => {\n            const handler = handlers[handlerKey];\n            return {\n                workletHash: handler.__workletHash,\n                closure: handler._closure,\n            };\n        });\n    }\n    else {\n        dependencies.push(buildWorkletsHash(handlers));\n    }\n    return dependencies;\n}\n// this is supposed to work as useEffect comparison\nfunction areDependenciesEqual(nextDeps, prevDeps) {\n    function is(x, y) {\n        /* eslint-disable no-self-compare */\n        return (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y);\n        /* eslint-enable no-self-compare */\n    }\n    const objectIs = typeof Object.is === 'function' ? Object.is : is;\n    function areHookInputsEqual(nextDeps, prevDeps) {\n        if (!nextDeps || !prevDeps || prevDeps.length !== nextDeps.length) {\n            return false;\n        }\n        for (let i = 0; i < prevDeps.length; ++i) {\n            if (!objectIs(nextDeps[i], prevDeps[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return areHookInputsEqual(nextDeps, prevDeps);\n}\nexport function useAnimatedGestureHandler(handlers, dependencies) {\n    const initRef = useRef(null);\n    if (initRef.current === null) {\n        initRef.current = {\n            context: makeRemote({}),\n            savedDependencies: [],\n        };\n    }\n    useEffect(() => {\n        return () => {\n            initRef.current = null;\n        };\n    }, []);\n    const { context, savedDependencies } = initRef.current;\n    dependencies = buildDependencies(dependencies, handlers);\n    const dependenciesDiffer = !areDependenciesEqual(dependencies, savedDependencies);\n    initRef.current.savedDependencies = dependencies;\n    const handler = (event) => {\n        'worklet';\n        event = Platform.OS === 'web' ? event.nativeEvent : event;\n        const FAILED = 1;\n        const BEGAN = 2;\n        const CANCELLED = 3;\n        const ACTIVE = 4;\n        const END = 5;\n        if (event.state === BEGAN && handlers.onStart) {\n            handlers.onStart(event, context);\n        }\n        if (event.state === ACTIVE && handlers.onActive) {\n            handlers.onActive(event, context);\n        }\n        if (event.oldState === ACTIVE && event.state === END && handlers.onEnd) {\n            handlers.onEnd(event, context);\n        }\n        if (event.oldState === BEGAN && event.state === FAILED && handlers.onFail) {\n            handlers.onFail(event, context);\n        }\n        if (event.oldState === ACTIVE &&\n            event.state === CANCELLED &&\n            handlers.onCancel) {\n            handlers.onCancel(event, context);\n        }\n        if ((event.oldState === BEGAN || event.oldState === ACTIVE) &&\n            event.state !== BEGAN &&\n            event.state !== ACTIVE &&\n            handlers.onFinish) {\n            handlers.onFinish(event, context, event.state === CANCELLED || event.state === FAILED);\n        }\n    };\n    if (Platform.OS === 'web') {\n        return handler;\n    }\n    return useEvent(handler, ['onGestureHandlerStateChange', 'onGestureHandlerEvent'], dependenciesDiffer);\n}\nexport function useAnimatedScrollHandler(handlers, dependencies) {\n    const initRef = useRef(null);\n    if (initRef.current === null) {\n        initRef.current = {\n            context: makeRemote({}),\n            savedDependencies: [],\n        };\n    }\n    useEffect(() => {\n        return () => {\n            initRef.current = null;\n        };\n    }, []);\n    const { context, savedDependencies } = initRef.current;\n    dependencies = buildDependencies(dependencies, handlers);\n    const dependenciesDiffer = !areDependenciesEqual(dependencies, savedDependencies);\n    initRef.current.savedDependencies = dependencies;\n    // build event subscription array\n    const subscribeForEvents = ['onScroll'];\n    if (handlers.onBeginDrag !== undefined) {\n        subscribeForEvents.push('onScrollBeginDrag');\n    }\n    if (handlers.onEndDrag !== undefined) {\n        subscribeForEvents.push('onScrollEndDrag');\n    }\n    if (handlers.onMomentumBegin !== undefined) {\n        subscribeForEvents.push('onMomentumScrollBegin');\n    }\n    if (handlers.onMomentumEnd !== undefined) {\n        subscribeForEvents.push('onMomentumScrollEnd');\n    }\n    return useEvent((event) => {\n        'worklet';\n        const { onScroll, onBeginDrag, onEndDrag, onMomentumBegin, onMomentumEnd, } = handlers;\n        if (event.eventName.endsWith('onScroll')) {\n            if (onScroll) {\n                onScroll(event, context);\n            }\n            else if (typeof handlers === 'function') {\n                handlers(event, context);\n            }\n        }\n        else if (onBeginDrag && event.eventName.endsWith('onScrollBeginDrag')) {\n            onBeginDrag(event, context);\n        }\n        else if (onEndDrag && event.eventName.endsWith('onScrollEndDrag')) {\n            onEndDrag(event, context);\n        }\n        else if (onMomentumBegin &&\n            event.eventName.endsWith('onMomentumScrollBegin')) {\n            onMomentumBegin(event, context);\n        }\n        else if (onMomentumEnd &&\n            event.eventName.endsWith('onMomentumScrollEnd')) {\n            onMomentumEnd(event, context);\n        }\n    }, subscribeForEvents, dependenciesDiffer);\n}\nexport function useAnimatedRef() {\n    const tag = useSharedValue(-1);\n    const ref = useRef(null);\n    if (!ref.current) {\n        const fun = function (component) {\n            'worklet';\n            // enters when ref is set by attaching to a component\n            if (component) {\n                tag.value = getTag(component);\n                fun.current = component;\n            }\n            return tag.value;\n        };\n        Object.defineProperty(fun, 'current', {\n            value: null,\n            writable: true,\n            enumerable: false,\n        });\n        ref.current = fun;\n    }\n    return ref.current;\n}\n/**\n * @param prepare - worklet used for data preparation for the second parameter\n * @param react - worklet which takes data prepared by the one in the first parameter and performs certain actions\n * the first worklet defines the inputs, in other words on which shared values change will it be called.\n * the second one can modify any shared values but those which are mentioned in the first worklet. Beware of that, because this may result in endless loop and high cpu usage.\n */\nexport function useAnimatedReaction(prepare, react, dependencies) {\n    const previous = useSharedValue(null);\n    if (dependencies === undefined) {\n        dependencies = [\n            Object.values(prepare._closure),\n            Object.values(react._closure),\n            prepare.__workletHash,\n            react.__workletHash,\n        ];\n    }\n    else {\n        dependencies.push(prepare.__workletHash, react.__workletHash);\n    }\n    useEffect(() => {\n        const fun = () => {\n            'worklet';\n            const input = prepare();\n            react(input, previous.value);\n            previous.value = input;\n        };\n        const mapperId = startMapper(fun, Object.values(prepare._closure), []);\n        return () => {\n            stopMapper(mapperId);\n        };\n    }, dependencies);\n}\nexport function useWorkletCallback(fun, deps) {\n    return useCallback(fun, deps);\n}\nexport function createWorklet(fun) {\n    return fun;\n}\n"
    ]
  },
  "metadata": {},
  "sourceType": "script"
}
